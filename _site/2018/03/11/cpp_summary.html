<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>学习笔记 - C++ - HouZAJ Blog</title>
    <meta name="author"  content="HouZAJ">
    <meta name="description" content="学习笔记 - C++">
    <meta name="keywords"  content="Programming">
    <!-- Open Graph -->
    <meta property="og:title" content="学习笔记 - C++ - HouZAJ Blog">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://localhost:4000/2018/03/11/cpp_summary.html">
    <meta property="og:description" content="A emmmmmmm developer">
    <meta property="og:site_name" content="HouZAJ Blog">
    <link rel="stylesheet" href="//cdn.staticfile.org/normalize/6.0.0/normalize.min.css">
    <link rel="stylesheet" href="/assets/css/github-markdown.css">
    <link href="/assets/css/prism.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/share.min.css">
    <link rel="stylesheet" href="/assets/css/app.min.css">
</head>

<body>
    <!--[if lt IE 10]>
<div class="alert-danger" role="alert">你的浏览器实在太太太旧了，放学别走，升级完浏览器再说！<a target="_blank" class="alert-link" href="http://browsehappy.com">立即升级</a></div>
<![endif]-->
<input id="nm-switch" type="hidden" value="false">

<header class="g-header">
    <i id="menu-toggle" class="iconfont icon-menu"></i>
    <nav class="g-nav">
        <ul>
            
            <li><a href="/">home</a></li>
            
            <li><a href="/tags.html">sorts</a></li>
            
        </ul>
    </nav>
</header>


<header class="g-banner post-header post-pattern-circuitBoard bgcolor-default " data-theme="default">
    <div class="post-wrapper">
        <div class="post-tags">
            
            
            <a href="http://localhost:4000/tags#Programming" class="post-tag">Programming</a>
            
            
        </div>
        <h1>学习笔记 - C++</h1>
        <div class="post-meta">
            <span class="post-meta-item"><i class="iconfont icon-author"></i><a href="http://localhost:4000" target="_blank" rel="author">HouZAJ</a></></span>
            <time class="post-meta-item" datetime="18-03-11"><i class="iconfont icon-date"></i>11 Mar 2018</time>
        </div>
    </div>
    
    <div class="filter"></div>
    <div class="post-cover" style="background: url('http://houzajblog-1252277898.coscd.myqcloud.com/20180108%20CPP/%E6%9C%AA%E6%A0%87%E9%A2%98-2-01.png') center no-repeat; background-size: cover;">
    
</header>

<div class="post-content">
    
    <article class="markdown-body">
        <blockquote>
  <p>C++ 是个无底洞……</p>
</blockquote>

<p><br /></p>

<iframe type="text/html" src="http://music.163.com/outchain/player?type=2&amp;id=33418878&amp;auto=0&amp;height=66" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86"></iframe>

<p><br /></p>

<blockquote>
  <p>目录</p>
</blockquote>

<ul id="markdown-toc">
  <li><a href="#更新日志0108---0311" id="markdown-toc-更新日志0108---0311">更新日志(0108 -&gt; 0311)</a></li>
  <li><a href="#part-i---前言" id="markdown-toc-part-i---前言">PART I - 前言</a></li>
  <li><a href="#part-ii---笔记" id="markdown-toc-part-ii---笔记">PART II - 笔记</a>    <ul>
      <li><a href="#零散点" id="markdown-toc-零散点">零散点</a>        <ul>
          <li><a href="#c的强制类型转换" id="markdown-toc-c的强制类型转换"><strong>C++的强制类型转换</strong></a></li>
          <li><a href="#新的操作符" id="markdown-toc-新的操作符"><strong>新的操作符</strong></a></li>
          <li><a href="#bool数据类型" id="markdown-toc-bool数据类型"><strong>bool数据类型</strong></a></li>
          <li><a href="#wchar_t数据类型" id="markdown-toc-wchar_t数据类型"><strong>wchar_t数据类型</strong></a></li>
          <li><a href="#auto类型-和-decltype类型-推断类型" id="markdown-toc-auto类型-和-decltype类型-推断类型"><strong>auto类型 和 decltype类型： 推断类型</strong></a></li>
          <li><a href="#assert函数" id="markdown-toc-assert函数"><strong>assert函数</strong></a></li>
          <li><a href="#eof函数" id="markdown-toc-eof函数"><strong>eof函数</strong></a></li>
          <li><a href="#内联函数" id="markdown-toc-内联函数"><strong>内联函数</strong></a></li>
          <li><a href="#全局变量的副作用" id="markdown-toc-全局变量的副作用"><strong>全局变量的副作用</strong></a></li>
          <li><a href="#函数重载" id="markdown-toc-函数重载"><strong>函数重载</strong></a></li>
          <li><a href="#枚举类型" id="markdown-toc-枚举类型"><strong>枚举类型</strong></a></li>
          <li><a href="#typedef语句" id="markdown-toc-typedef语句"><strong>typedef语句</strong></a></li>
          <li><a href="#namespace名字空间" id="markdown-toc-namespace名字空间"><strong>namespace(名字空间)</strong></a></li>
          <li><a href="#string数据类型" id="markdown-toc-string数据类型"><strong>string数据类型</strong></a></li>
          <li><a href="#定义二维数组的另一种方法" id="markdown-toc-定义二维数组的另一种方法"><strong>定义二维数组的另一种方法</strong></a></li>
          <li><a href="#头文件的包含和多重包含" id="markdown-toc-头文件的包含和多重包含"><strong>头文件的包含和多重包含</strong></a></li>
          <li><a href="#函数指针" id="markdown-toc-函数指针"><strong>函数指针</strong></a></li>
        </ul>
      </li>
      <li><a href="#引用" id="markdown-toc-引用"><strong>引用</strong></a>        <ul>
          <li><a href="#引用参数" id="markdown-toc-引用参数"><strong>引用参数</strong></a></li>
          <li><a href="#引用返回" id="markdown-toc-引用返回"><strong>引用返回</strong></a></li>
        </ul>
      </li>
      <li><a href="#cin-cout" id="markdown-toc-cin-cout"><strong>cin cout</strong></a>        <ul>
          <li><a href="#变量定义" id="markdown-toc-变量定义"><strong>变量定义</strong></a></li>
          <li><a href="#输入输出有关的函数" id="markdown-toc-输入输出有关的函数"><strong>输入输出有关的函数</strong></a></li>
          <li><a href="#输入失败" id="markdown-toc-输入失败"><strong>输入失败</strong></a></li>
          <li><a href="#格式化输出" id="markdown-toc-格式化输出"><strong>格式化输出</strong></a></li>
          <li><a href="#自定义的操纵器" id="markdown-toc-自定义的操纵器"><strong>自定义的操纵器</strong></a></li>
        </ul>
      </li>
      <li><a href="#文件输入输出" id="markdown-toc-文件输入输出"><strong>文件输入/输出</strong></a>        <ul>
          <li><a href="#一般文件的输入输出" id="markdown-toc-一般文件的输入输出"><strong>一般文件的输入/输出</strong></a></li>
          <li><a href="#open的更多细节" id="markdown-toc-open的更多细节"><strong>open的更多细节</strong></a></li>
          <li><a href="#文件指针" id="markdown-toc-文件指针"><strong>文件指针</strong></a></li>
          <li><a href="#串行的输入输出操作" id="markdown-toc-串行的输入输出操作"><strong>串行的输入输出操作</strong></a></li>
          <li><a href="#文件操纵时的错误处理" id="markdown-toc-文件操纵时的错误处理"><strong>文件操纵时的错误处理</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop-面向对象的基本概念" id="markdown-toc-oop-面向对象的基本概念"><strong>[OOP] 面向对象的基本概念</strong></a>        <ul>
          <li><a href="#面向对象的基本概念" id="markdown-toc-面向对象的基本概念"><strong>面向对象的基本概念</strong></a></li>
          <li><a href="#抽象数据类型abstract-data-type-adt" id="markdown-toc-抽象数据类型abstract-data-type-adt"><strong>抽象数据类型(Abstract data type, ADT)</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop-类" id="markdown-toc-oop-类"><strong>[OOP] 类</strong></a>        <ul>
          <li><a href="#类成员-与-类定义" id="markdown-toc-类成员-与-类定义"><strong>类成员 与 类定义</strong></a></li>
          <li><a href="#成员函数实现" id="markdown-toc-成员函数实现"><strong>成员函数实现</strong></a></li>
          <li><a href="#静态数据成员" id="markdown-toc-静态数据成员"><strong>静态数据成员</strong></a></li>
          <li><a href="#静态成员函数" id="markdown-toc-静态成员函数"><strong>静态成员函数</strong></a></li>
          <li><a href="#常量成员函数" id="markdown-toc-常量成员函数"><strong>常量成员函数</strong></a></li>
          <li><a href="#成员指针" id="markdown-toc-成员指针"><strong>成员指针</strong></a></li>
          <li><a href="#类与结构体" id="markdown-toc-类与结构体"><strong>类与结构体</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop-构造函数" id="markdown-toc-oop-构造函数"><strong>[OOP] 构造函数</strong></a>        <ul>
          <li><a href="#构造函数constructor" id="markdown-toc-构造函数constructor"><strong>构造函数(Constructor)</strong></a></li>
          <li><a href="#委托构造函数" id="markdown-toc-委托构造函数"><strong>委托构造函数</strong></a></li>
          <li><a href="#拷贝构造函数copy-constructor" id="markdown-toc-拷贝构造函数copy-constructor"><strong>拷贝构造函数(Copy Constructor)</strong></a></li>
          <li><a href="#移动构造函数" id="markdown-toc-移动构造函数"><strong>移动构造函数</strong></a></li>
          <li><a href="#析构函数destructor" id="markdown-toc-析构函数destructor"><strong>析构函数(Destructor)</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop-继承-和-组成" id="markdown-toc-oop-继承-和-组成"><strong>[OOP] 继承 和 组成</strong></a>        <ul>
          <li><a href="#继承is-a关系" id="markdown-toc-继承is-a关系"><strong>继承(“is-a”关系)</strong></a></li>
          <li><a href="#基类成员函数重定义" id="markdown-toc-基类成员函数重定义"><strong>基类成员函数重定义</strong></a></li>
          <li><a href="#基类和派生类的构造函数" id="markdown-toc-基类和派生类的构造函数"><strong>基类和派生类的构造函数</strong></a></li>
          <li><a href="#类保护成员protected" id="markdown-toc-类保护成员protected"><strong>类保护成员(protected)</strong></a></li>
          <li><a href="#继承public-private-protected" id="markdown-toc-继承public-private-protected"><strong>继承：public, private, protected</strong></a></li>
          <li><a href="#多继承" id="markdown-toc-多继承"><strong>多继承</strong></a></li>
          <li><a href="#虚基类" id="markdown-toc-虚基类"><strong>虚基类</strong></a></li>
          <li><a href="#有虚基类时的构造函数" id="markdown-toc-有虚基类时的构造函数"><strong>有虚基类时的构造函数</strong></a></li>
          <li><a href="#抽象类" id="markdown-toc-抽象类"><strong>抽象类</strong></a></li>
          <li><a href="#组成has-a关系" id="markdown-toc-组成has-a关系"><strong>组成(“has-a”关系)</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop-有关类的指针" id="markdown-toc-oop-有关类的指针"><strong>[OOP] 有关类的指针</strong></a>        <ul>
          <li><a href="#this指针" id="markdown-toc-this指针"><strong>this指针</strong></a></li>
          <li><a href="#派生类指针" id="markdown-toc-派生类指针"><strong>派生类指针</strong></a></li>
          <li><a href="#虚函数" id="markdown-toc-虚函数"><strong>虚函数</strong></a></li>
          <li><a href="#浅拷贝与深拷贝" id="markdown-toc-浅拷贝与深拷贝"><strong>浅拷贝与深拷贝</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop-重载" id="markdown-toc-oop-重载"><strong>[OOP] 重载</strong></a>        <ul>
          <li><a href="#类的友元函数friend-function" id="markdown-toc-类的友元函数friend-function"><strong>类的友元函数(Friend Function)</strong></a></li>
          <li><a href="#重载运算符限制" id="markdown-toc-重载运算符限制"><strong>重载运算符限制</strong></a></li>
          <li><a href="#作为成员函数重载---重载----等同理" id="markdown-toc-作为成员函数重载---重载----等同理"><strong>作为成员函数重载 +  （重载- / * 等同理）</strong></a></li>
          <li><a href="#作为成员函数重载关系运算符-" id="markdown-toc-作为成员函数重载关系运算符-"><strong>作为成员函数重载关系运算符 ==</strong></a></li>
          <li><a href="#作为非成员函数重载-" id="markdown-toc-作为非成员函数重载-"><strong>作为非成员函数重载 +</strong></a></li>
          <li><a href="#重载流插入和流析取运算符" id="markdown-toc-重载流插入和流析取运算符"><strong>重载流插入(«)和流析取(»)运算符</strong></a></li>
          <li><a href="#重载赋值运算符-" id="markdown-toc-重载赋值运算符-"><strong>重载赋值运算符 =</strong></a></li>
          <li><a href="#重载运算符-" id="markdown-toc-重载运算符-"><strong>重载运算符 []</strong></a></li>
          <li><a href="#重载运算符--1" id="markdown-toc-重载运算符--1"><strong>重载运算符 ++</strong></a></li>
          <li><a href="#重载成员访问运算符-" id="markdown-toc-重载成员访问运算符-"><strong>重载成员访问运算符 *</strong></a></li>
          <li><a href="#重载函数调用运算符函数对象" id="markdown-toc-重载函数调用运算符函数对象"><strong>重载函数调用运算符（函数对象）</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop-类型转换" id="markdown-toc-oop-类型转换"><strong>[OOP] 类型转换</strong></a>        <ul>
          <li><a href="#基本类型---类" id="markdown-toc-基本类型---类"><strong>基本类型 -&gt; 类</strong></a></li>
          <li><a href="#类---基本类型" id="markdown-toc-类---基本类型"><strong>类 -&gt; 基本类型</strong></a></li>
          <li><a href="#类a---类b" id="markdown-toc-类a---类b"><strong>类A -&gt; 类B</strong></a></li>
          <li><a href="#转换为bool" id="markdown-toc-转换为bool"><strong>转换为bool</strong></a></li>
          <li><a href="#显式类型转换运算符" id="markdown-toc-显式类型转换运算符"><strong>显式类型转换运算符</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop-模板" id="markdown-toc-oop-模板"><strong>[OOP] 模板</strong></a>        <ul>
          <li><a href="#函数模板" id="markdown-toc-函数模板"><strong>函数模板</strong></a></li>
          <li><a href="#类模板" id="markdown-toc-类模板"><strong>类模板</strong></a></li>
          <li><a href="#带多个参数的类模板和函数模板" id="markdown-toc-带多个参数的类模板和函数模板"><strong>带多个参数的类模板和函数模板</strong></a></li>
          <li><a href="#无类型模板参数" id="markdown-toc-无类型模板参数"><strong>无类型模板参数</strong></a></li>
        </ul>
      </li>
      <li><a href="#异常处理" id="markdown-toc-异常处理"><strong>异常处理</strong></a>        <ul>
          <li><a href="#基本概念" id="markdown-toc-基本概念"><strong>基本概念</strong></a></li>
          <li><a href="#异常处理机制" id="markdown-toc-异常处理机制"><strong>异常处理机制</strong></a></li>
          <li><a href="#捕捉机制" id="markdown-toc-捕捉机制"><strong>捕捉机制</strong></a></li>
          <li><a href="#重新抛出异常" id="markdown-toc-重新抛出异常"><strong>重新抛出异常</strong></a></li>
          <li><a href="#指定异常" id="markdown-toc-指定异常"><strong>指定异常</strong></a></li>
        </ul>
      </li>
      <li><a href="#标准模板库stl" id="markdown-toc-标准模板库stl"><strong>标准模板库(STL)</strong></a>        <ul>
          <li><a href="#容器" id="markdown-toc-容器"><strong>容器</strong></a></li>
          <li><a href="#算法" id="markdown-toc-算法"><strong>算法</strong></a></li>
          <li><a href="#迭代器" id="markdown-toc-迭代器"><strong>迭代器</strong></a></li>
          <li><a href="#函数对象" id="markdown-toc-函数对象"><strong>函数对象</strong></a></li>
        </ul>
      </li>
      <li><a href="#标准模板库stl的应用" id="markdown-toc-标准模板库stl的应用"><strong>标准模板库(STL)的应用</strong></a>        <ul>
          <li><a href="#string" id="markdown-toc-string"><strong>string</strong></a></li>
          <li><a href="#map" id="markdown-toc-map"><strong>map</strong></a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="更新日志0108---0311">更新日志(0108 -&gt; 0311)</h2>
<p><strong>概念性错误</strong></p>
<ol>
  <li>重载 » « 可作为类内成员</li>
  <li>为保持与内置版本一致，后置++需返回值，前置++需返回引用</li>
  <li>构造函数中的“也可写作”，改为“一般不写作”</li>
  <li><strong>[重要]</strong> extgcd()部分代码出错</li>
</ol>

<p><strong>具体新增内容</strong></p>
<ol>
  <li>重载函数调用运算符（函数对象）</li>
  <li>转换为bool</li>
  <li>面向对象的基本概念</li>
  <li>auto类型 和 decltype类型： 推断类型</li>
  <li>浅拷贝与深拷贝</li>
  <li>委托构造函数</li>
  <li>有虚基类时的构造函数</li>
</ol>

<p><strong>新增与修改</strong></p>
<ol>
  <li>参考加多两个</li>
  <li>增强部分解释与联系</li>
  <li>修改类构造函数默认书写方式</li>
  <li>STL的应用<br />
<br /></li>
</ol>

<h2 id="part-i---前言">PART I - 前言</h2>
<p>之前C++只啃了一点很基础的东西和学了些STL的用法方便打代码哈哈哈，然后期末还是没用到 _(:з」∠)_<br />
参考：</p>
<ol>
  <li>C++ Programming – Program Design Including Data Structures</li>
  <li>Data Structures, Algorithms, and Applications in C++</li>
  <li>Object Oriented Programming with C++ (Fourth Edition)</li>
  <li>C++ Primer</li>
  <li>学堂在线 —— C++语言程序设计进阶</li>
</ol>

<p><br /></p>

<h2 id="part-ii---笔记">PART II - 笔记</h2>
<h3 id="零散点">零散点</h3>
<h4 id="c的强制类型转换"><strong>C++的强制类型转换</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">//C语言的强制类型转换</span>
  <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">//C++的强制类型转换</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">7.9</span> <span class="o">+</span> <span class="mf">6.7</span><span class="p">);</span>    <span class="c1">//C++的强制类型转换</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="新的操作符"><strong>新的操作符</strong></h4>
<p>对这四个我是一脸蒙蔽啊……</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//static_cast操作符，用于强制类型转换</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">7.9</span> <span class="o">+</span> <span class="mf">6.7</span><span class="p">);</span>    
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//const_cast 操作符，显式改变变量的const或volatile属性</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">constant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">var</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">constant</span><span class="p">);</span>
    <span class="n">var</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"constant's value: "</span> <span class="o">&lt;&lt;</span> <span class="n">constant</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"var's value: "</span> <span class="o">&lt;&lt;</span> <span class="n">var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output:</span>
    <span class="c1">//constant's value: 1</span>
    <span class="c1">//var's value: 2</span>
    <span class="c1">//常量值依然不变，但两者地址相同，神奇！</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"constant's address: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">constant</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"var's address: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output:</span>
    <span class="c1">//constant's address: 0x7ffdba948dac</span>
    <span class="c1">//var's address: 0x7ffdba948dac</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//reinterpret_cast 操作符， 无视类型强型转换，过于强大一般不建议使用</span>
    <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">object</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//dynamic_cast 操作符，主要应用在执行多态对象的类型转换  </span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">object</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//typeid操作符，可用于在程序运行期间获取未知对象的类型，比如类名</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">objectType</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="n">object</span><span class="p">).</span><span class="n">name</span><span class="p">();</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="bool数据类型"><strong>bool数据类型</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">bool</span> <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">//相当于 = 1</span>
  <span class="kt">bool</span> <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//相当于 = 0</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="wchar_t数据类型"><strong>wchar_t数据类型</strong></h4>
<p>标准C++定义了字符类型 wchar_t，以存储16位宽的字符 <br />
标准C++引入了一种新的字符串，称为宽字符字符串</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">setlocale</span><span class="p">(</span><span class="n">LC_ALL</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
      <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">L"哈哈哈哈哈哈哈嗝emmm"</span><span class="p">;</span>
      <span class="n">wprintf</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 哈哈哈哈哈哈哈嗝emmm</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="auto类型-和-decltype类型-推断类型"><strong>auto类型 和 decltype类型： 推断类型</strong></h4>
<p><strong>auto</strong>：编译器会通过初始值自动推断变量的类型，可用来缩短类型名称 <br />
<strong>decltype</strong>： 定义一个变量与某一表达式的类型相同，并不用该表达式初始化变量</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//auto的栗子</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  <span class="c1">//auto自动推断为 vector&lt;int&gt;::iterator 类型</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>    <span class="c1">//等价于上一句</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// auto与decltype的比较</span>
  <span class="c1">// 对const</span>
  <span class="kt">double</span> <span class="n">a_var</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">a_con</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">a_var</span><span class="p">)</span> <span class="n">b_dec_var</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>   <span class="c1">// b_dec_var = 3.14</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">a_con</span><span class="p">)</span> <span class="n">b_dec_con</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>   <span class="c1">// b_dec_con = 3.14</span>
  <span class="k">auto</span> <span class="n">b_auto_var</span> <span class="o">=</span> <span class="n">a_var</span><span class="p">;</span>            <span class="c1">// b_auto_var = 3.14</span>
  <span class="k">auto</span> <span class="n">b_auto_con</span> <span class="o">=</span> <span class="n">a_con</span><span class="p">;</span>            <span class="c1">// b_auto_con = 3.14</span>
  <span class="n">b_dec_var</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>                   <span class="c1">// ok</span>
  <span class="c1">//b_dec_con = 3.14;                 // error，decltype保留const</span>
  <span class="n">b_auto_var</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>                  <span class="c1">// ok</span>
  <span class="n">b_auto_con</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>                  <span class="c1">// ok，auto不保留const</span>

  <span class="c1">// 对解引用操作</span>
  <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_auto</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>             <span class="c1">// d_auto是double型的，auto还原为原来的</span>
  <span class="k">decltype</span><span class="p">(</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="n">d_dec</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>      <span class="c1">// d_dec是double&amp;型的，decltype还原为引用的</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="assert函数"><strong>assert函数</strong></h4>
<p>终止程序执行，指出发生错误的表达式，包含错误源代码的文件名等，对提高代码质量起很大作用<br />
需包含头文件cassert或assert.h</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//输出：test3: ../test3/main.cpp:6: int main(): Assertion `b' failed.</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//输出：test3: ../test3/main.cpp:6: int main(): Assertion `b &gt; 0' failed.</span>
</code></pre></div></div>
<p>另外，可在预处理指令<code class="highlighter-rouge">#include &lt;cassert&gt;</code>前加入<code class="highlighter-rouge">#define NDEBUG</code>取消所有assert语句 <br />
<br /></p>

<h4 id="eof函数"><strong>eof函数</strong></h4>
<p>检测输入流变量是否遇到了文件结束标志<br />
在遇到文件结束标志时返回true，否则返回false</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">cin</span><span class="p">.</span><span class="n">eof</span><span class="p">()){</span>    <span class="c1">//写成 while(cin)也是可以的</span>
    <span class="c1">//Do Something</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="内联函数"><strong>内联函数</strong></h4>
<p>当其被调用时，代码将逐行展开，类似于宏展开</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kr">inline</span> <span class="kt">double</span> <span class="n">cube</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">){</span>   <span class="c1">//关键字inline</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="全局变量的副作用"><strong>全局变量的副作用</strong></h4>
<p>若多个函数都使用到某个全局变量，一旦出现差错，就很难发现是由哪个函数引起的<br />
在某个部分引起全局变量错误，易误以为是由另一部分引起的。<br />
<br /></p>

<h4 id="函数重载"><strong>函数重载</strong></h4>
<p>函数重载为多个函数使用同个名字，每个函数必须有不同的行参列表</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//可用函数larger判断两个int, char, double, string型变量的最大值，使用时无需使用四个函数，只需larger这一个函数</span>
  <span class="kt">int</span> <span class="nf">larger</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;}</span>
  <span class="kt">char</span> <span class="nf">larger</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">char</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;}</span>
  <span class="kt">double</span> <span class="nf">larger</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;}</span>
  <span class="n">string</span> <span class="nf">larger</span><span class="p">(</span><span class="n">string</span> <span class="n">x</span><span class="p">,</span> <span class="n">string</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//Do Something</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="枚举类型"><strong>枚举类型</strong></h4>
<p>略<br />
<br /></p>

<h4 id="typedef语句"><strong>typedef语句</strong></h4>
<p>创建已定义数据类型别名，常用来简化数据类型名</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ull</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">ull</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ll</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="namespace名字空间"><strong>namespace(名字空间)</strong></h4>
<p>ANSI/ISO标准C++试图用namespace来解决全局标识符名字重复的问题</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">namespace</span> <span class="n">temp</span><span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">temp</span><span class="p">;</span>   <span class="c1">//简化使用所有该namespace成员的语法</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//简化使用</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//简化使用</span>
  <span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">namespace</span> <span class="n">temp</span><span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">using</span> <span class="n">temp</span><span class="o">::</span><span class="n">a</span><span class="p">;</span>   <span class="c1">//简化使用某个该namespace成员的语法</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//简化使用</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span><span class="o">::</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="string数据类型"><strong>string数据类型</strong></h4>
<p>string是C++的字符串，比起C语言中用字符数组那是简单得多，具体语法如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">str_sub</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>

  <span class="n">string</span> <span class="n">str3</span> <span class="o">=</span> <span class="n">str1</span> <span class="o">+</span> <span class="sc">' '</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>  <span class="c1">//str3 == "Hello World"</span>
  <span class="n">str3</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'w'</span><span class="p">;</span>  <span class="c1">//可用下标访问与修改, str3 == "Hello world"</span>
  <span class="n">len</span> <span class="o">=</span> <span class="n">str3</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>  <span class="c1">//获取长度，也可用str3.size();</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="n">str3</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"or"</span><span class="p">);</span>  <span class="c1">//查找子串，失败返回npos</span>
  <span class="n">str_sub</span> <span class="o">=</span> <span class="n">str3</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">//返回子串，6为开始位置，5为长度，str_sub == "world"</span>
  <span class="n">str1</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>  <span class="c1">//交换子串， str1 == "World", str2 == "Hello"  </span>

  <span class="n">str1</span> <span class="o">&lt;</span> <span class="n">str2</span><span class="p">;</span>    <span class="c1">//可以直接用 &gt; &gt;= == &lt;= &lt; 比较两个字符串  </span>

  <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">str1</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>    <span class="c1">//读取整行字符串直到遇到','，第三个参数可省略</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="定义二维数组的另一种方法"><strong>定义二维数组的另一种方法</strong></h4>
<p>先用typedef定义一个二位数组数据类型，然后用该类型来定义数组</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">const</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">tableType</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>
  <span class="n">tableType</span> <span class="n">matrix</span><span class="p">;</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="头文件的包含和多重包含"><strong>头文件的包含和多重包含</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include &lt;iostream&gt;   //系统提供的头文件用 &lt; &gt;
</span>  <span class="cp">#include "myHeaderFile.h"   //用户定义的用 " "
</span></code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//写头文件时使用以下格式可避免多重包含变量导致编译错误</span>
  <span class="c1">//Header file</span>
  <span class="cp">#ifndef H_test    //if not define，第二次包含时已经define就会跳过下面的代码
</span>  <span class="cp">#define H_test
</span>    <span class="c1">//Do Something</span>
  <span class="cp">#endif
</span></code></pre></div></div>
<p><br /></p>

<h4 id="函数指针"><strong>函数指针</strong></h4>
<p>在C++中广泛被用于动态绑定和基于事件的应用</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span> <span class="n">FunPtr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>   <span class="c1">//typedef简化代码</span>
  <span class="kt">void</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" + "</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">Sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" - "</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">FunPtr</span> <span class="n">ptr</span><span class="p">;</span>   <span class="c1">//声明</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Add</span><span class="p">;</span>   <span class="c1">//绑定Add函数</span>
      <span class="n">ptr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
      <span class="c1">//Output: 3 + 5 = 8</span>

      <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Sub</span><span class="p">;</span>
      <span class="n">ptr</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>    <span class="c1">//绑定Sub函数</span>
      <span class="c1">//Output: 5 - 3 = 2</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="引用"><strong>引用</strong></h3>
<h4 id="引用参数"><strong>引用参数</strong></h4>
<p>引用参数接受实参的内存地址，因此在以下三种情况中十分适用：</p>
<ol>
  <li>要从参数中返回多一个值，如<code class="highlighter-rouge">扩展欧几里德算法</code>：
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">extgcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">){</span>
   <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
   <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
     <span class="n">d</span> <span class="o">=</span> <span class="n">extgcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
     <span class="n">y</span> <span class="o">-=</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
   <span class="p">}</span><span class="k">else</span><span class="p">{</span>
     <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
     <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>实参值本身需要改动，如<code class="highlighter-rouge">交换函数</code>：
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
 <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
 <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
 <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>传递地址可以节省拷贝大量数据所需的内存空间和时间</li>
</ol>

<p><br /></p>

<h4 id="引用返回"><strong>引用返回</strong></h4>
<p>到C++写类时非常常用，这里在只举一个简单的栗子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">&amp;</span> <span class="n">max</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">//引用传参且返回引用</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">//将-1赋给a,b中的最大值, a = -1</span>
<span class="p">}</span>
</code></pre></div></div>
<p>另外特别注意！上栗中a, b需要引用传参，因为如果不用引用的话，函数内a,b只是拷贝出来的变量，退出作用域后销毁，返回会失效<br />
<br /></p>

<h3 id="cin-cout"><strong>cin cout</strong></h3>
<h4 id="变量定义"><strong>变量定义</strong></h4>
<p>头文件iostream中包含cin、cout的变量定义</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">istream</span> <span class="n">cin</span><span class="p">;</span>
  <span class="n">ostream</span> <span class="n">cout</span><span class="p">;</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="输入输出有关的函数"><strong>输入输出有关的函数</strong></h4>
<p>cin.get、cout.put函数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//读取一个字符存到ch中，空格、回车均可存     </span>
  <span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>  

  <span class="c1">//输出字符</span>
  <span class="n">cout</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>    
</code></pre></div></div>

<p>cin.getline、cout.write函数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
  <span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>  <span class="c1">//读取到 \n 或 20-1个字符</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//Input:  123456 78910</span>
  <span class="c1">//Output: 123456 78910</span>

  <span class="c1">//Input:  123456 789101112131415</span>
  <span class="c1">//Output: 123456 789101112131</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Apple"</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">cout</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//Output:</span>
  <span class="c1">//A</span>
  <span class="c1">//Ap</span>
  <span class="c1">//App</span>
  <span class="c1">//Appl</span>
  <span class="c1">//Apple</span>
</code></pre></div></div>

<p>cin.ignore、cin.putback、cin.peek函数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//忽略掉下面100个字符 或者 忽略掉下个'\n'之前的所有字符   </span>
  <span class="n">cin</span><span class="p">.</span><span class="n">ignore</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">);</span>   
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//把ch变量退回输入流中    </span>
  <span class="n">cin</span><span class="p">.</span><span class="n">putback</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//检测下一个字符为何值</span>
  <span class="n">ch</span> <span class="o">=</span> <span class="n">cin</span><span class="p">.</span><span class="n">peek</span><span class="p">();</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="输入失败"><strong>输入失败</strong></h4>
<p>类型不匹配导致输入失败时（如将小数点’.’读入int型变量中），输入流会处于Fail State（错误状态），接下来使用该输入流的所有I/O语句都将被忽略掉，使用clear()函数可使其恢复到正常状态。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//使cin流恢复正常状态</span>
  <span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="格式化输出"><strong>格式化输出</strong></h4>
<ul>
  <li><strong>头文件</strong><br />
  需包含头文件iomanip</li>
  <li><strong>fixed, scientific, showpoint, setprecision</strong>
    <ul>
      <li><code class="highlighter-rouge">setprecision(n)</code> : 将输出的小数点指定为n位，一次设置，永久生效，直到下一个setprecision(n)覆盖设置</li>
      <li><code class="highlighter-rouge">fixed</code> : 固定小数点形式</li>
      <li><code class="highlighter-rouge">showpoint</code> : 强制显示输出数字的小数点和小数点后面的0</li>
      <li><code class="highlighter-rouge">scientific</code> : 以科学计数法形式输出</li>
    </ul>

    <p>在标准C++的环境下，需要通过setf函数或者setiosflags函数控制符两种方式来使用</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/*
      第一种方式：最常见方式
      cout &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(2);
  */</span>
  <span class="cm">/*
      第二种方式：使用流函数来指定fixed, scientific, showpoint
      cout.setf(ios::fixed, ios::floatfield);
      cout.setf(ios::showpoint);
      cout &lt;&lt; setprecision(2);
  */</span>
  <span class="cm">/*
      第三种方式：使用setiosflags控制符
      cout &lt;&lt; setiosflags(ios::fixed | ios::showpoint);
      cout &lt;&lt; setprecision(2);
  */</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">1.234</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>      <span class="c1">//1.23</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">123456.0</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">//123456.00</span>
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">scientific</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">123456.0</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">//1.234560e+05</span>
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//取消fixed</span>
  <span class="n">cout</span><span class="p">.</span><span class="n">unsetf</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">fixed</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>setw, fill, setfill</strong>
    <ul>
      <li><code class="highlighter-rouge">setw(n)</code> : 设置域宽为n</li>
      <li><code class="highlighter-rouge">fill</code> : 全局设置填充字符</li>
      <li><code class="highlighter-rouge">setfill</code> : 当前输出语句设置填充字符</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cout</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="sc">'*'</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">setfill</span><span class="p">(</span><span class="sc">'#'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//****1####2</span>
</code></pre></div>    </div>
  </li>
  <li><strong>setw, fill, setfill</strong><br />
顾名思义，左右对齐。下面以left举例，right可同理。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/*
    第一种方式：最常见方式
    cout &lt;&lt; left;
  */</span>
  <span class="cm">/*
    第二种方式：使用流函数
    cout.setf(ios::left, ios::adjustfield);
  */</span>
  <span class="cm">/*
    第三种方式：使用setiosflags控制符
    cout &lt;&lt; setiosflags(ios::left);
  */</span>
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//取消left</span>
  <span class="n">cout</span><span class="p">.</span><span class="n">unsetf</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">left</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>endl, flush</strong><br />
 endl会将光标移到下一行开头(‘\n’)，并清空缓冲区(相当于执行flush)函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">//即使缓冲区的数据没有存满也可以显示提示信息</span>
   <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter an intger:"</span> <span class="o">&lt;&lt;</span> <span class="n">flush</span><span class="p">;</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h4 id="自定义的操纵器"><strong>自定义的操纵器</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">unit</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">){</span>     <span class="c1">//语法</span>
      <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">" GB"</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">unit</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//output: 3 GB</span>
  <span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="文件输入输出"><strong>文件输入/输出</strong></h3>
<h5 id="一般文件的输入输出"><strong>一般文件的输入/输出</strong></h5>
<p>恕我直言，OJ生成随机数据常用……<br />
大致模板如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 声明流变量</span>
  <span class="n">ifstream</span> <span class="n">inData</span><span class="p">;</span>
  <span class="n">ofstream</span> <span class="n">outData</span><span class="p">;</span>

  <span class="c1">// 打开文件</span>
  <span class="n">inData</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"FilePath1"</span><span class="p">);</span>    <span class="c1">//打开文件路径为FilePath1的文件</span>
  <span class="n">outData</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"FilePath2"</span><span class="p">);</span>

  <span class="p">{</span>
     <span class="c1">// Do Something</span>
     <span class="c1">//把inData当作cin， outData当作cout使用，同文本重定向操作</span>
  <span class="p">}</span>

  <span class="c1">// 关闭文件</span>
  <span class="n">inData</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
  <span class="n">outData</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</code></pre></div></div>
<p>可把inData改为cin，outData改为cout，这样就直接变成文本重定向 <br />
<br /></p>

<h4 id="open的更多细节"><strong>open的更多细节</strong></h4>
<p>open第二个参数是mode，可指定打开文件目的，具体如下：</p>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>意义</th>
      <th>参数</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ios::app</td>
      <td>添加到文件尾</td>
      <td>ios::nocreate</td>
      <td>若不存在，打开失败</td>
    </tr>
    <tr>
      <td>ios::ate</td>
      <td>打开时就到文件尾</td>
      <td>ios::noreplace</td>
      <td>若已存在，打开失败</td>
    </tr>
    <tr>
      <td>ios::binary</td>
      <td>二进制文件</td>
      <td>ios::out</td>
      <td>只写</td>
    </tr>
    <tr>
      <td>ios::in</td>
      <td>只读</td>
      <td>ios::trunc</td>
      <td>若已存在，删除所有内容</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="文件指针"><strong>文件指针</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ifstream</span> <span class="n">in</span><span class="p">;</span>
    <span class="n">ofstream</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">in</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"FilePath"</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>
    <span class="n">out</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"FilePath"</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">app</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">tellg</span><span class="p">();</span>     <span class="c1">//取得输入指针</span>
    <span class="kt">int</span> <span class="n">pout</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="n">tellp</span><span class="p">();</span>   <span class="c1">//取得输出指针</span>

    <span class="n">in</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">//移动到指定位置，0代表文件头</span>
    <span class="n">out</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>
<p>seekg和seekp具体用法如下表：<br />
其中cur代表当前，begin为文件头，end为文件尾</p>

<table>
  <thead>
    <tr>
      <th>seek函数调用</th>
      <th>行为</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fout.seekg(m, ios::cur)</td>
      <td>指针前移m个字节</td>
    </tr>
    <tr>
      <td>fout.seekg(-m, ios::cur)</td>
      <td>指针后移m个字节</td>
    </tr>
    <tr>
      <td>fout.seekg(m, ios::beg)</td>
      <td>移到到m+1个字节处</td>
    </tr>
    <tr>
      <td>fout.seekg(-m, ios::end)</td>
      <td>从文件尾后移m个字节</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="串行的输入输出操作"><strong>串行的输入输出操作</strong></h4>
<p>cin.put, cout.get是和之前一样的，略<br />
cin.read, cout.write用于二进制形式输入输出，存储速度快</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ofstream</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">ifstream</span> <span class="n">in</span><span class="p">;</span>
    <span class="n">out</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"/home/a/1.out"</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">3.14</span><span class="p">,</span> <span class="mf">6.28</span><span class="p">,</span> <span class="mf">2.7100</span><span class="p">,</span> <span class="mf">9.99990</span><span class="p">};</span>
    <span class="kt">double</span> <span class="n">arr2</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">));</span>   <span class="c1">//语法</span>
    <span class="n">out</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

    <span class="n">in</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"/home/a/1.out"</span><span class="p">);</span>
    <span class="n">in</span><span class="p">.</span><span class="n">read</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">arr2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr2</span><span class="p">));</span>     <span class="c1">//同样是语法</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">arr2</span><span class="p">,</span> <span class="n">arr2</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">" "</span><span class="p">));</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: 3.14 6.28 2.71 9.9999</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="文件操纵时的错误处理"><strong>文件操纵时的错误处理</strong></h4>
<p>错误处理函数如下：</p>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>返回值和意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>eof()</td>
      <td>读取到文件尾返回true</td>
    </tr>
    <tr>
      <td>fail()</td>
      <td>输入输出操作失败返回true</td>
    </tr>
    <tr>
      <td>bad()</td>
      <td>有非法操作时，或有不可恢复的错误发生时，返回true</td>
    </tr>
    <tr>
      <td>good()</td>
      <td>无错误返回true，返回false不能进行任何操作</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="oop-面向对象的基本概念"><strong>[OOP] 面向对象的基本概念</strong></h3>
<h4 id="面向对象的基本概念"><strong>面向对象的基本概念</strong></h4>
<ol>
  <li><strong>对象</strong>： 程序中用来描述客观事物的实体</li>
  <li><strong>抽象</strong>： 抽象出同一类对象的共同属性和行为形成类</li>
  <li><strong>封装</strong>： 把数据和数据上的操作组合在一个独立单元中的能力 (类 class)， 隐蔽对象的内部细节，只保留有限的对外接口</li>
  <li><strong>继承</strong>： 在现有的对象基础上创建新的对象的能力 (继承inheritance, 组合)，意义在于软件复用</li>
  <li><strong>多态</strong>： 使用相同表达式指定不同操作的能力</li>
</ol>

<p><br /></p>

<h4 id="抽象数据类型abstract-data-type-adt"><strong>抽象数据类型(Abstract data type, ADT)</strong></h4>
<p>只确定逻辑特性而没有实现细节的数据类型，有3个相关属性：</p>
<ol>
  <li><strong>类型名称(Data Type Name)</strong></li>
  <li><strong>域(Domain)</strong>： 即属于ADT的一系列值</li>
  <li><strong>一系列操作(Operations)</strong></li>
</ol>

<p>由此可定义clockType抽象数据类型如下所示，从中可见，类是实现ADT的一种便利的方法</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">dataTypeName</span>
    <span class="n">clockType</span>
  <span class="n">domain</span>
    <span class="n">each</span> <span class="n">clockType</span> <span class="n">value</span> <span class="n">is</span> <span class="n">a</span> <span class="n">time</span> <span class="n">of</span> <span class="n">day</span> <span class="n">in</span> <span class="n">the</span> <span class="n">form</span> <span class="n">of</span> <span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span><span class="p">,</span> <span class="n">and</span> <span class="n">seconds</span><span class="p">.</span>
  <span class="n">operations</span>
    <span class="n">Set</span> <span class="n">the</span> <span class="n">time</span><span class="p">.</span>
    <span class="n">Return</span> <span class="n">the</span> <span class="n">time</span><span class="p">.</span>
    <span class="p">......</span>
</code></pre></div></div>
<p>接下来要说的类，是实现ADT的一种便利的方法<br />
<br /></p>

<h3 id="oop-类"><strong>[OOP] 类</strong></h3>
<h4 id="类成员-与-类定义"><strong>类成员 与 类定义</strong></h4>
<p>类成员分为：<br />
<strong>公有成员(public)</strong>： 作为外部接口，任何外部函数都可访问类的public成员<br />
<strong>私有成员(private)</strong>： 只允许本类中的函数访问，类外函数不能访问（友元除外，友元函数在后面！）<br />
<strong>受保护成员(protected)</strong>：  允许派生类内函数的访问 (protected成员在后面！) <br />
如定义clockType类，并在其中说明为什么类是实现ADT的一种便利的方式</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>    <span class="c1">//ADT的类型名称</span>
  <span class="k">private</span><span class="o">:</span>      <span class="c1">//私有成员不能被类外部访问，类内部默认为private，故若private出现在public和protected前面时可以省略</span>
      <span class="c1">//ADT的domain</span>
      <span class="kt">int</span> <span class="n">hr</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">min</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>

  <span class="k">public</span><span class="o">:</span>
      <span class="c1">// ADT的Operations</span>
      <span class="kt">void</span> <span class="n">setTime</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">getTime</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">printTime</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
      <span class="kt">void</span> <span class="n">incrementSeconds</span><span class="p">();</span>
      <span class="kt">void</span> <span class="n">incrementMinutes</span><span class="p">();</span>
      <span class="kt">void</span> <span class="n">incrementHours</span><span class="p">();</span>
      <span class="kt">bool</span> <span class="n">equalTime</span><span class="p">(</span><span class="k">const</span> <span class="n">clockType</span><span class="o">&amp;</span> <span class="n">otherClock</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>    <span class="c1">//传引用可提高性能（因为无需拷贝）</span>
  <span class="p">};</span>
</code></pre></div></div>
<p>另外注意：</p>
<ol>
  <li>不能在变量定义时同时初始化</li>
  <li>类成员函数在类内一般只用函数原型定义，因为如果在类中提供函数原型，会导致类定义变长，以至于难以理解，同时与信息隐藏有关</li>
  <li>当函数定义于类内时，会变为inline函数，所有内联函数的限制和局限也适用于此，故只有小函数才定义在类的定义内</li>
</ol>

<p><br /></p>

<h4 id="成员函数实现"><strong>成员函数实现</strong></h4>
<p>以setTime函数为栗子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>
    <span class="c1">//......</span>
  <span class="p">};</span>

  <span class="kt">void</span> <span class="n">clockType</span><span class="o">::</span><span class="n">setTime</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">){</span>
      <span class="n">hr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">hours</span> <span class="o">&amp;&amp;</span> <span class="n">hours</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">?</span><span class="n">hours</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
      <span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">minutes</span> <span class="o">&amp;&amp;</span> <span class="n">minutes</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">minutes</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
      <span class="n">seconds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">seconds</span> <span class="o">&amp;&amp;</span> <span class="n">seconds</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">seconds</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="静态数据成员"><strong>静态数据成员</strong></h4>
<p>特点：</p>
<ol>
  <li>类的第一个对象被创建时，一次性被初始化为0</li>
  <li>所有实例共享一个静态成员变量</li>
  <li>只在类内可见</li>
  <li>生存期为程序整个执行期</li>
  <li>每个静态成员变量的类型和作用域，都定义于类的定义之外，与类关联但和对象没有关系</li>
  <li>声明于类内，定义于源文件内</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">test</span><span class="o">::</span><span class="n">a</span><span class="p">;</span>  <span class="c1">//静态成员函数的定义</span>

    <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
        <span class="n">test</span> <span class="n">obj1</span><span class="p">;</span>
        <span class="n">test</span> <span class="n">obj2</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="c1">//Output: 0</span>

        <span class="n">obj1</span><span class="p">.</span><span class="n">fun</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">obj2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="c1">//Output: 1 1</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="静态成员函数"><strong>静态成员函数</strong></h4>
<p>特点：</p>
<ol>
  <li>只能访问类内声明的其他静态成员（函数或变量）</li>
  <li>调用时使用类名，而非对象名</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">showA</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">test</span><span class="o">::</span><span class="n">a</span><span class="p">;</span>  <span class="c1">//静态成员函数的定义</span>

    <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
        <span class="n">test</span> <span class="n">obj1</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test</span><span class="o">::</span><span class="n">showA</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="c1">//Output: 0</span>

        <span class="n">obj1</span><span class="p">.</span><span class="n">fun</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test</span><span class="o">::</span><span class="n">showA</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="c1">//Output: 1</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="常量成员函数"><strong>常量成员函数</strong></h4>
<p>可将不改变任何类内数据的函数声明为常量成员函数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="n">get_balance</span><span class="p">()</span>  <span class="k">const</span><span class="p">;</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="成员指针"><strong>成员指针</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">A</span><span class="o">::*</span> <span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">m</span><span class="p">;</span>   <span class="c1">//A::* 为“指向类A的成员的指针”， &amp;A::m 为 “类A的成员的地址”  </span>
</code></pre></div></div>

<p><strong>mutable</strong>: 使常量成员函数能够修改被mutable修饰的变量的值</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">data2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
      <span class="kt">void</span> <span class="n">modify</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
      <span class="k">mutable</span> <span class="kt">int</span> <span class="n">data2</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">void</span> <span class="n">test</span><span class="o">::</span><span class="n">modify</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
      <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">//error: assignment of member ‘test::data’ in read-only object</span>
      <span class="n">data2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//ok</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="类与结构体"><strong>类与结构体</strong></h4>
<p>如果类的所有数据成员都是公有成员，不包含任何成员函数，那么一般使用结构体<br />
<br /></p>

<h3 id="oop-构造函数"><strong>[OOP] 构造函数</strong></h3>
<h4 id="构造函数constructor"><strong>构造函数(Constructor)</strong></h4>
<p>通过构造函数来保证类中数据成员的初始化，可有多个进行重载<br />
当声明对象时，构造函数将自动执行<br />
构造函数应使用 <strong>构造函数初始值列表</strong> 初始化类成员，<strong>赋值会先初始化后复制</strong>（编译器不支持该成员的默认初始化就GG）</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="c1">//省略成员函数</span>
      <span class="n">clockType</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">);</span>  <span class="c1">//带参数的构造函数</span>
      <span class="n">clockType</span><span class="p">();</span>  <span class="c1">//默认构造函数</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">hr</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">min</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//相关实现</span>
  <span class="n">clockType</span><span class="o">::</span><span class="n">clockType</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">){</span>
      <span class="n">hr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">hours</span> <span class="o">&amp;&amp;</span> <span class="n">hours</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">?</span><span class="n">hours</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
      <span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">minutes</span> <span class="o">&amp;&amp;</span> <span class="n">minutes</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">minutes</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
      <span class="n">seconds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">seconds</span> <span class="o">&amp;&amp;</span> <span class="n">seconds</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">seconds</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">clockType</span><span class="o">::</span><span class="n">clockType</span><span class="p">()</span><span class="o">:</span> <span class="n">hr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">sec</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>    <span class="c1">// 构造函数初始化值列表</span>
  <span class="c1">//一般不写作 clockType::clockType()  { hr = 0; min = 0; sec = 0; }  ，因为赋值会先初始化后赋值</span>
</code></pre></div></div>
<p>构造函数可带默认参数，也称为默认构造函数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="c1">//省略成员函数</span>
      <span class="n">clockType</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">//默认构造函数</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">hr</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">min</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//相关实现</span>
  <span class="n">clockType</span><span class="o">::</span><span class="n">clockType</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">){</span>
      <span class="n">hr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">hours</span> <span class="o">&amp;&amp;</span> <span class="n">hours</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">?</span><span class="n">hours</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
      <span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">minutes</span> <span class="o">&amp;&amp;</span> <span class="n">minutes</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">minutes</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
      <span class="n">seconds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">seconds</span> <span class="o">&amp;&amp;</span> <span class="n">seconds</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">seconds</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">clockType</span> <span class="n">myclock1</span><span class="p">;</span>
    <span class="n">clockType</span> <span class="n">myclock2</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="委托构造函数"><strong>委托构造函数</strong></h4>
<p>用其他的构造函数来构造某个构造函数，如</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="c1">//省略成员函数</span>
      <span class="n">clockType</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">);</span>
      <span class="n">clockType</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">hr</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">min</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//相关实现</span>
  <span class="c1">//省略clockType(int hours, int minutes, int seconds)的实现</span>

  <span class="n">clockType</span><span class="o">::</span><span class="n">clockType</span><span class="p">()</span><span class="o">:</span> <span class="n">clockType</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>   
  <span class="c1">//委托给clockType(int hours, int minutes, int seconds)进行构造</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="拷贝构造函数copy-constructor"><strong>拷贝构造函数(Copy Constructor)</strong></h4>
<p>用已经存在的类对象进行初始化需使用拷贝构造函数，十分重要的点！</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">myVector</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">myVector</span><span class="p">();</span>
      <span class="n">myVector</span><span class="p">(</span><span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="n">anotherVector</span><span class="p">);</span>    <span class="c1">//拷贝构造函数</span>
      <span class="o">~</span><span class="n">myVector</span><span class="p">();</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">unsigned</span> <span class="n">t_size</span><span class="p">;</span>
      <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(){</span>
      <span class="n">t_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
      <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t_size</span><span class="p">]();</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(</span><span class="k">const</span> <span class="n">myVector</span> <span class="o">&amp;</span><span class="n">anotherVector</span><span class="p">){</span>
      <span class="n">t_size</span> <span class="o">=</span> <span class="n">anotherVector</span><span class="p">.</span><span class="n">t_size</span><span class="p">;</span>      <span class="c1">//t_size在向量中会改变，故要拷贝</span>
      <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t_size</span><span class="p">];</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>    <span class="c1">//深拷贝</span>
          <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">anotherVector</span><span class="p">.</span><span class="n">p</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>    <span class="c1">//注意需要打括号，优先级问题</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">myVector</span><span class="o">::~</span><span class="n">myVector</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">myVector</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//主函数----------------------------------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">myVector</span> <span class="n">vec</span><span class="p">;</span>
      <span class="n">myVector</span> <span class="n">vec2</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
      <span class="n">vec2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">//Output:</span>
      <span class="c1">//0 1 2 3 4 5 6 7 8 9</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="移动构造函数"><strong>移动构造函数</strong></h4>
<p>移动构造函数可将要返回的局部对象转移到主调函数,省去了构造和删除临时对象的过程 <br />
在 <strong>有可被利用的临时对象</strong> 时可使用 <br />
可参考 <a href="http://blog.csdn.net/shenwanjiang111/article/details/53576196">C++类的特殊成员-默认/拷贝/移动构造函数</a><br />
<br /></p>

<h4 id="析构函数destructor"><strong>析构函数(Destructor)</strong></h4>
<p>每个类只能有一个析构函数，在程序退出类对象的作用域（即类对象被释放）时，自动执行类的析构函数。<br />
有指针数据成员的类若有创建动态对象，都需要有析构函数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//如在类中new了数组后，在实例退出作用域时需要将其删除，可编写析构函数delete掉</span>
  <span class="k">class</span> <span class="nc">myVector</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">myVector</span><span class="p">();</span>
    <span class="o">~</span><span class="n">myVector</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(){</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="n">myVector</span><span class="o">::~</span><span class="n">myVector</span><span class="p">(){</span>
    <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"clear done!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//主函数----------------------------------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">n_case</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n_case</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">myVector</span> <span class="n">vec</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">//Output</span>
  <span class="c1">//clear done!</span>
  <span class="c1">//clear done!</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="oop-继承-和-组成"><strong>[OOP] 继承 和 组成</strong></h3>
<h4 id="继承is-a关系"><strong>继承(“is-a”关系)</strong></h4>
<p>从现有类的基础上创建新类</p>
<ul>
  <li><strong>派生类(Derived class)</strong> : 创建的新类，创建的新类的新类……</li>
  <li><strong>现有类(Base class)</strong> : 从现有类的基础上创建新类</li>
  <li><strong>单继承(Single inheritance)</strong> : 派生类从一个基类派生</li>
  <li><strong>多继承(Multiple inheritance)</strong> : 派生类从多个基类派生</li>
  <li><strong>多级继承</strong>： 基类派生出中间基类，中间基类再派生出派生类，即 A -&gt; B -&gt; C</li>
  <li><strong>层次继承</strong>： 子类从基类派生，作为继承的基类，类似河流主流和分流，作为继承类的在主流，派生类在直流</li>
  <li><strong>混合继承</strong>： 顾名思义！</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//例如：cirle类和rectangle类从shape类派生</span>
    <span class="k">class</span> <span class="nc">circle</span><span class="o">:</span> <span class="k">public</span> <span class="n">shape</span><span class="p">{</span>   <span class="c1">//shape类的public成员变成cirle类的public成员</span>
      <span class="c1">//Do Something</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">circle</span><span class="o">:</span> <span class="k">private</span> <span class="n">rectangle</span><span class="p">{</span>    <span class="c1">//shape类的public成员变成cirle类的private成员(private可省略)</span>
      <span class="c1">//Do Something</span>
    <span class="p">};</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="基类成员函数重定义"><strong>基类成员函数重定义</strong></h4>
<p>在baseClass中包含print函数，在derivedClass中也包含print函数且参数列表相同，则为基类成员函数重定义</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">baseClass</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
      <span class="n">baseClass</span><span class="p">()</span> <span class="p">{</span><span class="n">base_var</span> <span class="o">=</span> <span class="s">"base_var"</span><span class="p">;}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">base_var</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">derivedClass</span><span class="o">:</span> <span class="k">public</span> <span class="n">baseClass</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
      <span class="n">derivedClass</span><span class="p">()</span>  <span class="p">{</span><span class="n">derived_var</span> <span class="o">=</span> <span class="s">"derived_var"</span><span class="p">;}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">derived_var</span><span class="p">;</span>
   <span class="p">};</span>

  <span class="kt">void</span> <span class="n">baseClass</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base_var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">derivedClass</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
      <span class="n">baseClass</span><span class="o">::</span><span class="n">print</span><span class="p">();</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">derived_var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">baseClass</span> <span class="n">base_object</span><span class="p">;</span>
      <span class="n">derivedClass</span> <span class="n">derived_object</span><span class="p">;</span>
      <span class="n">base_object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">// Output:</span>
      <span class="c1">// derived_var</span>

      <span class="n">derived_object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">//Output:</span>
      <span class="c1">// base_var</span>
      <span class="c1">// derived_var</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="基类和派生类的构造函数"><strong>基类和派生类的构造函数</strong></h4>
<p>派生类执行自身构造函数和触发基类构造函数代码如下，值得一提的是，派生类会先调用基类构造函数，再调用自身构造函数，调用析构函数时，先调用自身的再调用基类的</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">baseClass</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
      <span class="n">baseClass</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">);</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">base_var</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">derivedClass</span><span class="o">:</span> <span class="k">public</span> <span class="n">baseClass</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
      <span class="n">derivedClass</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">,</span> <span class="n">string</span> <span class="n">var2</span><span class="p">);</span>  <span class="c1">//var是给derviedClass的，var2是给baseClass的</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">derived_var</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// ---------------------------------------</span>
  <span class="n">baseClass</span><span class="o">::</span><span class="n">baseClass</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span> <span class="o">=</span> <span class="s">"base_bar by default"</span><span class="p">){</span>    <span class="c1">//基类构造函数</span>
      <span class="n">base_var</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">derivedClass</span><span class="o">::</span><span class="n">derivedClass</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span> <span class="o">=</span> <span class="s">"derived_var"</span><span class="p">,</span>
   <span class="n">string</span> <span class="n">var2</span> <span class="o">=</span> <span class="s">"base_var provoked by derivedClass"</span><span class="p">)</span><span class="o">:</span><span class="n">baseClass</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">//触发基类构造函数</span>
      <span class="n">derived_var</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">baseClass</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base_var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">derivedClass</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
      <span class="n">baseClass</span><span class="o">::</span><span class="n">print</span><span class="p">();</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">derived_var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// ---------------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">baseClass</span> <span class="n">base_object</span><span class="p">;</span>
      <span class="n">derivedClass</span> <span class="n">derived_object</span><span class="p">;</span>
      <span class="n">base_object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">// Output:</span>
      <span class="c1">// base_var by default</span>

      <span class="n">derived_object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">// Output:</span>
      <span class="c1">// base_var provoked by derivedClass</span>
      <span class="c1">// derived_var</span>

      <span class="n">derivedClass</span> <span class="n">derived_object2</span><span class="p">(</span><span class="s">"derived_bar by user"</span><span class="p">,</span> <span class="s">"base_bar by user"</span><span class="p">);</span>
      <span class="n">derived_object2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">// Output:</span>
      <span class="c1">// base_bar by user</span>
      <span class="c1">// derived_bar by user</span>

      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br />
<strong>[OJ 填空题] 继承自string的MyString</strong><br />
这道题惊艳到我了！<br />
好好学习天天向上！</p>
<blockquote>
  <p><strong>样例输入</strong></p>
  <blockquote>
    <p>无</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>样例输出</strong></p>
  <blockquote>
    <ol>
      <li>abcd-efgh-abcd-</li>
      <li>abcd-</li>
      <li></li>
      <li>abcd-efgh-</li>
      <li>efgh-</li>
      <li>c</li>
      <li>abcd-</li>
      <li>ijAl-</li>
      <li>ijAl-mnop</li>
      <li>qrst-abcd-</li>
      <li>abcd-qrst-abcd- uvw xyz<br />
 about<br />
 big<br />
 me<br />
 take<br />
 abcd<br />
 qrst-abcd-</li>
    </ol>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>提示</strong></p>
  <blockquote>
    <p><strong>提示 1：</strong> 如果将程序中所有 “MyString” 用 “string” 替换，那么除
    了最后两条红色的语句编译无法通过外，其他语句都没有问题，而且输出和前
    面给的结果吻合。也就是说，MyString 类对 string 类的功能扩充只体现在最
    后两条语句上面。<br />
<strong>提示 2:</strong> string 类有一个成员函数 string substr(int start,int
    length); 能够求从 start 位置开始，长度为 length 的子串<br />
<strong>提示 3:</strong> C++中，派生类的对象可以赋值给基类对象，因为，一个派生
    类对象，也可看作是一个基类对象（大学生是学生）。反过来则不行(学生未
    必是大学生） 同样，调用需要基类对象作参数的函数时，以派生类对象作为实参，也是没有问题的</p>
  </blockquote>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include &lt;cstdlib&gt;
</span>  <span class="cp">#include &lt;iostream&gt;
</span>  <span class="cp">#include &lt;string&gt;
</span>  <span class="cp">#include &lt;algorithm&gt;
</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MyString</span><span class="o">:</span><span class="k">public</span> <span class="n">string</span>
  <span class="p">{</span>

      <span class="c1">// 在此处补充你的代码 ------------------------------------------------------------------------</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">MyString</span><span class="p">()</span><span class="o">:</span> <span class="n">string</span><span class="p">()</span> <span class="p">{}</span>   <span class="c1">//触发基类string类构造函数</span>
      <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">//触发基类string类构造函数</span>
      <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>   <span class="c1">//触发基类string类构造函数</span>
      <span class="c1">//触发基类string类构造函数，这里把派生类对象s交给string类构造函数处理是没问题的，反之则不行</span>
      <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>   
      <span class="n">MyString</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>    <span class="c1">//因此这是唯一的拓展</span>
          <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">substr</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>          <span class="c1">//但其实也是调用一下string类的方法substr然后完事</span>
      <span class="p">}</span>
      <span class="c1">// -----------------------------------------------------------------------------------------</span>

  <span class="p">};</span>


  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">MyString</span> <span class="n">s1</span><span class="p">(</span><span class="s">"abcd-"</span><span class="p">),</span><span class="n">s2</span><span class="p">,</span><span class="n">s3</span><span class="p">(</span><span class="s">"efgh-"</span><span class="p">),</span><span class="n">s4</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
      <span class="n">MyString</span> <span class="n">SArray</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"big"</span><span class="p">,</span><span class="s">"me"</span><span class="p">,</span><span class="s">"about"</span><span class="p">,</span><span class="s">"take"</span><span class="p">};</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"1. "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span> <span class="o">&lt;&lt;</span> <span class="n">s3</span><span class="o">&lt;&lt;</span> <span class="n">s4</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">s4</span> <span class="o">=</span> <span class="n">s3</span><span class="p">;</span>
      <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s3</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2. "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"3. "</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"4. "</span> <span class="o">&lt;&lt;</span> <span class="n">s3</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"5. "</span> <span class="o">&lt;&lt;</span> <span class="n">s4</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"6. "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
      <span class="n">s1</span> <span class="o">=</span> <span class="s">"ijkl-"</span><span class="p">;</span>
      <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'A'</span> <span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"7. "</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"8. "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">s1</span> <span class="o">+=</span> <span class="s">"mnop"</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"9. "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">s4</span> <span class="o">=</span> <span class="s">"qrst-"</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"10. "</span> <span class="o">&lt;&lt;</span> <span class="n">s4</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">s1</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">+</span> <span class="n">s4</span> <span class="o">+</span> <span class="s">" uvw "</span> <span class="o">+</span> <span class="s">"xyz"</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"11. "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
          <span class="n">sort</span><span class="p">(</span><span class="n">SArray</span><span class="p">,</span><span class="n">SArray</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span><span class="n">i</span> <span class="o">++</span> <span class="p">)</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">SArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//s1的从下标0开始长度为4的子串</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//s1的从下标5开始长度为10的子串</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="类保护成员protected"><strong>类保护成员(protected)</strong></h4>
<p>可访问性介于public和private之间，派生类可以直接访问基类protected成员 <br />
<br /></p>

<h4 id="继承public-private-protected"><strong>继承：public, private, protected</strong></h4>
<p>假设B Class 从 A Class派生，A成员在B成员中的属性如下表  <br />
下表中√表示可以直接访问，〇表示可以间接访问，×表示不能访问（除友元函数） <br />
（友元函数通吃一切！）</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">memberAccessSpecifier A</th>
      <th style="text-align: center">A’s public</th>
      <th style="text-align: center">A’s protected</th>
      <th style="text-align: center">A’s private</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">public</td>
      <td style="text-align: center">√ (public)</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">×</td>
    </tr>
    <tr>
      <td style="text-align: center">protected</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">×</td>
    </tr>
    <tr>
      <td style="text-align: center">private</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">×</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="多继承"><strong>多继承</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">,</span> <span class="k">public</span> <span class="n">B</span><span class="p">{</span>  <span class="c1">//多继承语法</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">C</span> <span class="n">obj</span><span class="p">;</span>
      <span class="n">obj</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>  <span class="c1">//继承A，可访问</span>
      <span class="n">obj</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>  <span class="c1">//继承B，可访问</span>
      <span class="n">obj</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>  <span class="c1">//自身的，可访问</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="虚基类"><strong>虚基类</strong></h4>
<p>当某类被设为虚基类时，不管虚基类和派生类间有多少继承路径，C++都会确保只有一份该类的成员被继承<br />
可避免多重路径继承引起的成员重复（比如菱形状的）</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="c1">//...</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B1</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
    <span class="c1">//...</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B2</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
    <span class="c1">//...</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B1</span><span class="p">,</span> <span class="k">public</span> <span class="n">B2</span><span class="p">{</span>   <span class="c1">//因为B1，B2继承A时使用虚基类，所以C最终只会继承一份A，不会引起成员重复  </span>
    <span class="c1">//...</span>
  <span class="p">};</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="有虚基类时的构造函数"><strong>有虚基类时的构造函数</strong></h4>
<p>建立对象时所指定的类称为 <strong>最远派生类</strong><br />
虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的<br />
在整个继承结构中,直接或间接继承虚基类的所有派生类,都必须在构造函数的成员初始化表中为虚基类的构造函数列出参数。如果未列出,则表示调用该虚基类的默认构造函数<br />
在建立对象时,只有最远派生类的构造函数调用虚基类的构造函数,其他类对虚基类构造函数的调用被忽略</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">var_A</span><span class="p">;</span>
      <span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
      <span class="n">A</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">)</span><span class="o">:</span> <span class="n">var_A</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>   <span class="p">{}</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B1</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">var_B1</span><span class="p">;</span>
      <span class="n">B1</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">)</span><span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="s">"B1 to A"</span><span class="p">),</span> <span class="n">var_B1</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>   <span class="p">{}</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B2</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">var_B2</span><span class="p">;</span>
      <span class="n">B2</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">){</span>
           <span class="n">A</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="s">"B2 to A"</span><span class="p">);</span>
           <span class="n">var_B2</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B1</span><span class="p">,</span> <span class="k">public</span> <span class="n">B2</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">var_C</span><span class="p">;</span>
      <span class="n">C</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">)</span><span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="s">"C to A"</span><span class="p">),</span> <span class="n">B1</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="s">"C to B1"</span><span class="p">),</span> <span class="n">B2</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="s">"C to B2"</span><span class="p">),</span> <span class="n">var_C</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>  <span class="p">{}</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">A</span> <span class="n">obj_A</span><span class="p">(</span><span class="s">"A's var "</span><span class="p">);</span>
      <span class="n">B1</span> <span class="n">obj_B1</span><span class="p">(</span><span class="s">"B1's var "</span><span class="p">);</span>
      <span class="n">B2</span> <span class="n">obj_B2</span><span class="p">(</span><span class="s">"B2's var "</span><span class="p">);</span>
      <span class="n">C</span> <span class="n">obj_C</span><span class="p">(</span><span class="s">"C's var "</span><span class="p">);</span>


      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj_A</span><span class="p">.</span><span class="n">var_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">// Output:</span>
      <span class="c1">// A's var</span>


      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj_B1</span><span class="p">.</span><span class="n">var_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj_B1</span><span class="p">.</span><span class="n">var_B1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">// Output:</span>
      <span class="c1">// B1's var B1 to A</span>
      <span class="c1">// B1's var</span>


      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj_C</span><span class="p">.</span><span class="n">var_A</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>    <span class="c1">//B1,B2中A的构造函数被忽略，但必须写</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj_C</span><span class="p">.</span><span class="n">var_B1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj_C</span><span class="p">.</span><span class="n">var_B2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj_C</span><span class="p">.</span><span class="n">var_C</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">// Output:</span>
      <span class="c1">// C's var C to A</span>
      <span class="c1">// C's var C to B1</span>
      <span class="c1">// C's var C to B2</span>
      <span class="c1">// C's var</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="抽象类"><strong>抽象类</strong></h4>
<p>C++支持两种类：<code class="highlighter-rouge">抽象类</code>和<code class="highlighter-rouge">具体类</code>，抽象类中包含没有实现的成员函数（<code class="highlighter-rouge">纯虚函数</code>），纯虚函数用0作为初始值<br />
具体类是没有纯虚函数的类，只有具体类才可实例化，抽象类一般作为基类派生出具体类<br />
下面是一个具体类的栗子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">linearList</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="c1">//析构函数需要为虚函数，作用是能调用引用对象中数据类型的析构函数，如果不写只会调用基类的析构函数，派生类的不会被调用</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">linearList</span><span class="p">()</span> <span class="p">{}</span>
      <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span>  <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="kt">int</span> <span class="n">size</span><span class="p">()</span>  <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">erase</span><span class="p">(</span><span class="kt">int</span> <span class="n">theIndex</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="组成has-a关系"><strong>组成(“has-a”关系)</strong></h4>
<p>也称嵌套类<br />
如在personType类中包含dataType类和personalType类，代码如下</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//datatype类-------------------------------------------------------</span>
  <span class="k">class</span> <span class="nc">dateType</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">dateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">dYear</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">dMonth</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">dDay</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">dateType</span><span class="o">::</span><span class="n">dateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="mi">2018</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="mi">30</span><span class="p">){</span>   <span class="c1">//dataType的默认构造函数</span>
      <span class="n">dYear</span> <span class="o">=</span> <span class="n">year</span><span class="p">;</span>
      <span class="n">dMonth</span> <span class="o">=</span> <span class="n">month</span><span class="p">;</span>
      <span class="n">dDay</span> <span class="o">=</span> <span class="n">day</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">dateType</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Date: "</span> <span class="o">&lt;&lt;</span> <span class="n">dYear</span> <span class="o">&lt;&lt;</span> <span class="s">"-"</span> <span class="o">&lt;&lt;</span> <span class="n">dMonth</span> <span class="o">&lt;&lt;</span> <span class="s">"-"</span> <span class="o">&lt;&lt;</span> <span class="n">dDay</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// personalType类----------------------------------------------</span>
  <span class="k">class</span> <span class="nc">personalType</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">personalType</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">dName</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">personalType</span><span class="o">::</span><span class="n">personalType</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"null"</span><span class="p">){</span>
      <span class="n">dName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">personalType</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Name: "</span> <span class="o">&lt;&lt;</span> <span class="n">dName</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//persoanlInfo类--------------------------------------------------</span>
  <span class="k">class</span> <span class="nc">personalInfo</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">personalInfo</span><span class="p">();</span>
      <span class="n">personalInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="n">string</span> <span class="n">name</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">personalType</span> <span class="n">personalName</span><span class="p">;</span>
      <span class="n">dateType</span> <span class="n">bDay</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">personalInfo</span><span class="o">::</span><span class="n">personalInfo</span><span class="p">(){}</span>    <span class="c1">//使用对象成员构造函数的默认值</span>
  <span class="n">personalInfo</span><span class="o">::</span><span class="n">personalInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span>
     <span class="n">string</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span><span class="n">personalName</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">bDay</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">){}</span>  <span class="c1">//向成员对象的构造函数传递参数</span>

  <span class="kt">void</span> <span class="n">personalInfo</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">personalName</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="n">bDay</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">//主函数----------------------------------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">personalInfo</span> <span class="n">student</span><span class="p">;</span>
    <span class="n">student</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output</span>
    <span class="c1">//Name: null</span>
    <span class="c1">//Date: 2018-2-30</span>

    <span class="n">personalInfo</span> <span class="n">student2</span><span class="p">(</span><span class="mi">1999</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s">"your nick name"</span><span class="p">);</span>
    <span class="n">student2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output</span>
    <span class="c1">//Name: your nick name</span>
    <span class="c1">//Date: 1999-9-9</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="oop-有关类的指针"><strong>[OOP] 有关类的指针</strong></h3>
<h4 id="this指针"><strong>this指针</strong></h4>
<p>this指针为指向对象自己的指针</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>   <span class="k">const</span><span class="p">;</span>
      <span class="n">A</span> <span class="n">get</span><span class="p">()</span>   <span class="k">const</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">print</span><span class="p">()</span>  <span class="k">const</span>  <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>

  <span class="n">A</span> <span class="n">A</span><span class="o">::</span><span class="n">get</span><span class="p">()</span> <span class="k">const</span>  <span class="p">{</span> <span class="k">return</span>  <span class="o">*</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">A</span> <span class="n">instanceA</span><span class="p">;</span>
      <span class="n">A</span> <span class="n">instanceB</span><span class="p">;</span>
      <span class="n">instanceA</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">instanceA</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="n">instanceB</span> <span class="o">=</span> <span class="n">instanceA</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
      <span class="n">instanceB</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//一个神奇的栗子</span>
  <span class="k">class</span> <span class="nc">person</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">person</span><span class="o">&amp;</span> <span class="n">setFirstName</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">);</span>   <span class="c1">//此处返回的是引用</span>
      <span class="n">person</span><span class="o">&amp;</span> <span class="n">setLastName</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">first_name</span><span class="p">;</span>
      <span class="n">string</span> <span class="n">last_name</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">person</span><span class="o">&amp;</span> <span class="n">person</span><span class="o">::</span><span class="n">setFirstName</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">){</span> <span class="n">first_name</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">person</span><span class="o">&amp;</span> <span class="n">person</span><span class="o">::</span><span class="n">setLastName</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">){</span> <span class="n">last_name</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">person</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">first_name</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">last_name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">person</span> <span class="n">null</span><span class="p">;</span>
      <span class="n">null</span><span class="p">.</span><span class="n">setFirstName</span><span class="p">(</span><span class="s">"Name"</span><span class="p">).</span><span class="n">setLastName</span><span class="p">(</span><span class="s">"Error"</span><span class="p">);</span>  <span class="c1">//因为返回引用且为自身*this，故可连续用两次.</span>
      <span class="n">null</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">//Output</span>
      <span class="c1">//Name Error</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="派生类指针"><strong>派生类指针</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">public_data_a</span><span class="p">;</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">private_data_a</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">public_data_b</span><span class="p">;</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">private_data_b</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">B</span> <span class="n">objB</span><span class="p">;</span>

      <span class="n">A</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">objB</span><span class="p">;</span>         <span class="c1">//基类指针绑定派生类实例</span>
      <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">public_data_a</span><span class="p">;</span>     <span class="c1">//能访问基类的成员，不能访问派生类的成员</span>

      <span class="n">B</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">objB</span><span class="p">;</span>        <span class="c1">//派生类指针绑定派生类实例</span>
      <span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">public_data_a</span><span class="p">;</span>    <span class="c1">//都能访问！</span>
      <span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">public_data_b</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="虚函数"><strong>虚函数</strong></h4>
<p>参考1里面似乎写的不好，或者是本人愚笨…故用 <a href="https://baike.baidu.com/item/%E8%99%9A%E5%87%BD%E6%95%B0/2912832?fr=aladdin">百度百科——虚函数</a> 和 <a href="https://www.zhihu.com/question/23971699">知乎——c++虚函数的作用是什么？</a> 加以辅助<br />
在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，可实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数<br />
虚函数的绑定发生在程序执行期间(动态绑定 Run-time Binding)，在编译时，编译器向系统提供必要信息，使得运行时系统能产生实际代码来调用相应函数<br />
另外注意：<strong>如果基类包含了虚函数，基类的析构函数同时也要设为虚函数</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>   <span class="c1">//只需要在基类加上virtual，派生类不需要</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's in A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">B</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's in B"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">callPrint</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">){</span>   <span class="c1">//注意使用引用或者指针传参</span>
      <span class="n">p</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// -----------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">A</span> <span class="n">instanceA</span><span class="p">;</span>
      <span class="n">B</span> <span class="n">instanceB</span><span class="p">;</span>
      <span class="n">callPrint</span><span class="p">(</span><span class="n">instanceA</span><span class="p">);</span>
      <span class="n">callPrint</span><span class="p">(</span><span class="n">instanceB</span><span class="p">);</span>
      <span class="c1">//Output：</span>
      <span class="c1">//It's in A</span>
      <span class="c1">//It's in B</span>

      <span class="c1">//若不加virtual，Output：</span>
      <span class="c1">//It's in A</span>
      <span class="c1">//It's in A</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="浅拷贝与深拷贝"><strong>浅拷贝与深拷贝</strong></h4>
<p><strong>浅拷贝</strong>： 实现对象间数据元素的一一对应复制。
<strong>深拷贝</strong>： 当被复制的对象数据成员是指针类型时,不是复制该指针成员本身,而是将指针所指对象进行复制 <br />
应尽量避免浅拷贝而使用深拷贝，深拷贝栗子看 <strong>重载赋值运算符 =</strong><br />
<br /></p>

<h3 id="oop-重载"><strong>[OOP] 重载</strong></h3>
<h4 id="类的友元函数friend-function"><strong>类的友元函数(Friend Function)</strong></h4>
<p>友元函数指在类作用域范围之外的函数，<strong>它是类的非成员函数</strong>，但是能访问类的私有数据成员<br />
为了确保数据的完整性,及数据封装与隐藏的原则,建议尽量不使用或少使用友元。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">B</span><span class="p">;</span>    <span class="c1">//前向引用声明，因为下面的函数cSwap需要用到</span>
  <span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
      <span class="c1">//下面一句是友元函数，函数原型前需加上friend</span>
      <span class="k">friend</span> <span class="kt">void</span> <span class="n">cSwap</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">cA</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">cB</span><span class="p">);</span>  <span class="c1">//这是一个交换两个类数据的函数，需要用到友元函数，注意传的是引用</span>
      <span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">B</span><span class="p">()</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
      <span class="k">friend</span> <span class="kt">void</span> <span class="n">cSwap</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">cA</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">cB</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">get</span><span class="p">(){</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">void</span> <span class="n">cSwap</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">cA</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">cB</span><span class="p">){</span>    <span class="c1">//友元函数定义，前面不需要加上friend</span>
      <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cA</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
      <span class="n">cA</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cB</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
      <span class="n">cB</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ---------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">A</span> <span class="n">instanceA</span><span class="p">;</span>
      <span class="n">B</span> <span class="n">instanceB</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">instanceA</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">instanceB</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 1 2</span>

      <span class="n">cSwap</span><span class="p">(</span><span class="n">instanceA</span><span class="p">,</span> <span class="n">instanceB</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">instanceA</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">instanceB</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 2 1</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="重载运算符限制"><strong>重载运算符限制</strong></h4>
<p>以下说明需在刷题中慢慢体会</p>
<ol>
  <li>不能改变运算符的优先级和结合律</li>
  <li>不能使用默认参数，不能改变运算符所需参数个数</li>
  <li>不能创建新运算符</li>
  <li>不能重载以下运算符 <br />
 <code class="highlighter-rouge">.</code>  |  <code class="highlighter-rouge">.*</code>  |  <code class="highlighter-rouge">::</code> | <code class="highlighter-rouge">?:</code> | <code class="highlighter-rouge">sizeof</code></li>
  <li>重载运算符 <code class="highlighter-rouge">()</code>, <code class="highlighter-rouge">[]</code>, <code class="highlighter-rouge">-&gt;</code>, <code class="highlighter-rouge">=</code> 的函数一定要声明为类的成员，因为他们的左值都是类对象</li>
  <li>重载<code class="highlighter-rouge">&lt;&lt;</code>, <code class="highlighter-rouge">&gt;&gt;</code>一定要作为非成员（友元函数），除非那个类就是起到输入输出流的作用</li>
  <li>假定OpOverClass类重载运算符op，则：<br />
    - 若op最左边的操作数不是OpOverClass类型，则重载运算符op的函数一定要作为非成员（友元）<br />
    - 若重载运算符op的函数是OpOverClass类的成员，则当opo用于OpOverClass类型的对象时，op最左边的操作数必须是OpOverClass类型</li>
</ol>

<p><br /></p>

<h4 id="作为成员函数重载---重载----等同理"><strong>作为成员函数重载 +  （重载- / * 等同理）</strong></h4>
<p>以复数相加为栗子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ComplexNum</span><span class="p">()</span>  <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>

        <span class="c1">// 下面是运算符+重载的函数原型，ComplexNum是返回类型，operator+其实是函数名，(const ComplexNum&amp;) 则是右值  </span>
        <span class="c1">// 仔细想想，其实和普通的类内函数声明没有区别  </span>
        <span class="c1">// 另外注意返回不能是引用，原因看下面</span>
        <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span><span class="p">)</span>   <span class="k">const</span><span class="p">;</span>
        <span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">//重载运算符语法如下面这一句</span>
    <span class="n">ComplexNum</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">other_complex_num</span><span class="p">)</span>  <span class="k">const</span><span class="p">{</span>
        <span class="n">ComplexNum</span> <span class="n">res</span><span class="p">;</span>   <span class="c1">// 重载+需要定义一个先的类对象返回，如果返回引用，res退出函数已被销毁，引用会失效</span>
        <span class="n">res</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span> <span class="o">+</span> <span class="n">other_complex_num</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">vir</span> <span class="o">=</span> <span class="n">vir</span> <span class="o">+</span> <span class="n">other_complex_num</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="n">display</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">vir</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// -------------------------</span>
    <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
        <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
        <span class="n">ComplexNum</span> <span class="n">num3</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="p">;</span>  <span class="c1">//等价于 num1.operator+(num2)</span>
        <span class="n">num3</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
        <span class="c1">//Output: 3+6i</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="作为成员函数重载关系运算符-"><strong>作为成员函数重载关系运算符 ==</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>
        <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span><span class="p">)</span>   <span class="k">const</span><span class="p">;</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">bool</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">other_complex_num</span><span class="p">)</span>  <span class="k">const</span><span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">real</span> <span class="o">==</span> <span class="n">other_complex_num</span><span class="p">.</span><span class="n">real</span> <span class="o">&amp;&amp;</span> <span class="n">vir</span> <span class="o">==</span> <span class="n">other_complex_num</span><span class="p">.</span><span class="n">vir</span><span class="p">)</span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// -------------------------</span>
    <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
        <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">num1</span> <span class="o">==</span> <span class="n">num2</span><span class="p">)</span><span class="o">?</span><span class="s">"TURE"</span><span class="o">:</span><span class="s">"FALSE"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="c1">//Output: FALSE</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="作为非成员函数重载-"><strong>作为非成员函数重载 +</strong></h4>
<p>把上面的复数重载+拿下来改改</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ComplexNum</span><span class="p">()</span>  <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>
        <span class="k">friend</span> <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">)</span>   <span class="p">;</span>  <span class="c1">//函数原型1</span>
        <span class="k">friend</span> <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">)</span>   <span class="p">;</span>  <span class="c1">//函数原型2</span>
        <span class="k">friend</span> <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">)</span>   <span class="p">;</span>  <span class="c1">//函数原型3</span>
        <span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">//分别重载complex + complex, complex + int, int + complex三种情况</span>
    <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span> <span class="o">&amp;</span><span class="n">second</span><span class="p">){</span>
        <span class="n">ComplexNum</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">vir</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">vir</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">){</span>
        <span class="n">ComplexNum</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">second</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">vir</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">){</span>
        <span class="n">ComplexNum</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">second</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">vir</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="n">display</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">vir</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// ---------------------------------------------</span>
    <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
        <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
        <span class="n">ComplexNum</span> <span class="n">num3</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">num3</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
        <span class="c1">//Output: 10+6i</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="重载流插入和流析取运算符"><strong>重载流插入(«)和流析取(»)运算符</strong></h4>
<p>仍以复数为栗子（这个栗子太好举了！）</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>
      <span class="c1">//&lt;&lt; &gt;&gt; 重载的函数原型如下</span>
      <span class="c1">//注意ostream和istream是不可以改变的，其为输入输出流</span>
      <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">ostreamObject</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">);</span>
      <span class="k">friend</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">istreamObject</span><span class="p">,</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">);</span>  <span class="c1">//注意没有const，const就不能输入了！</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">ostreamObject</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">){</span>
      <span class="n">ostreamObject</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">vir</span> <span class="o">&lt;&lt;</span> <span class="s">"i)"</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">ostreamObject</span><span class="p">;</span>   <span class="c1">//注意return，后续可能接着用到</span>
  <span class="p">}</span>

  <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">istreamObject</span><span class="p">,</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">){</span>
      <span class="n">istreamObject</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">.</span><span class="n">real</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">istreamObject</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// -------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
      <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
      <span class="n">ComplexNum</span> <span class="n">num3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num3</span><span class="p">;</span>
      <span class="c1">//Input: 3 6</span>

      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num1</span> <span class="o">&lt;&lt;</span> <span class="s">" + "</span> <span class="o">&lt;&lt;</span> <span class="n">num2</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">num3</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: (1,2i) + (2,4i) = (3,6i)</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="重载赋值运算符-"><strong>重载赋值运算符 =</strong></h4>
<p>重载 = 运算符，可避免有指针数据成员的类的浅拷贝<br />
这次以之前用过的向量类来举例子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">myVector</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">myVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">);</span>
      <span class="o">~</span><span class="n">myVector</span><span class="p">();</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
      <span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">unsigned</span> <span class="n">t_size</span><span class="p">;</span>
      <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
      <span class="n">t_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t_size</span><span class="p">]();</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>  <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">myVector</span><span class="o">::~</span><span class="n">myVector</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">myVector</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="n">myVector</span><span class="o">::</span><span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">){</span>     <span class="c1">//避免自身复制，浪费时间空间</span>
          <span class="n">t_size</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">t_size</span><span class="p">;</span>
          <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>    <span class="c1">//深拷贝</span>
              <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">p</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//主函数----------------------------------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">myVector</span> <span class="n">vec</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">myVector</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
      <span class="n">vec</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="n">vec2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">//Output:</span>
      <span class="c1">//0 1 2 3 4</span>
      <span class="c1">//10 11 12 13 14</span>

      <span class="n">vec</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">;</span>
      <span class="n">vec</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="n">vec2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">//Output:</span>
      <span class="c1">//10 11 12 13 14</span>
      <span class="c1">//10 11 12 13 14</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="重载运算符-"><strong>重载运算符 []</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//重载下标[]，以向量为栗</span>
  <span class="k">class</span> <span class="nc">myVector</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">myVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">);</span>
      <span class="o">~</span><span class="n">myVector</span><span class="p">();</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
      <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">);</span>     <span class="c1">//重载下标[]</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">unsigned</span> <span class="n">t_size</span><span class="p">;</span>
      <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
      <span class="n">t_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t_size</span><span class="p">]();</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>  <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">myVector</span><span class="o">::~</span><span class="n">myVector</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">myVector</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span><span class="o">&amp;</span> <span class="n">myVector</span><span class="o">::</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">){</span>
      <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">//主函数----------------------------------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">myVector</span> <span class="n">vec</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">myVector</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">vec</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="重载运算符--1"><strong>重载运算符 ++</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//重载自增运算符</span>
  <span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>

      <span class="c1">// 重载前置自增，自减同理，注意为与内置版本一致，需返回引用</span>
      <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span><span class="p">();</span>

      <span class="c1">// 重载后置自增，自减同理，其中int i无实际意义，仅起标识为后置的作用，注意为与内置版本一致，需返回值   </span>
      <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>  
      <span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="k">operator</span> <span class="o">++</span><span class="p">(){</span>
      <span class="n">ComplexNum</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
      <span class="n">real</span><span class="o">++</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">ComplexNum</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
      <span class="n">ComplexNum</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
      <span class="n">real</span><span class="o">++</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="n">display</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">vir</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// -------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
      <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
      <span class="n">num1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
      <span class="n">num2</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
      <span class="c1">//Output:</span>
      <span class="c1">//1+2i</span>
      <span class="c1">//2+4i</span>

      <span class="n">num1</span><span class="o">++</span><span class="p">;</span>   <span class="c1">// 相当于 num1.operator++(0);</span>
      <span class="o">++</span><span class="n">num2</span><span class="p">;</span>   <span class="c1">// 相当于 num2.operator++;</span>
      <span class="n">num1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
      <span class="n">num2</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
      <span class="c1">//Output:</span>
      <span class="c1">//2+2i</span>
      <span class="c1">//3+4i</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="重载成员访问运算符-"><strong>重载成员访问运算符 *</strong></h4>
<p>略<br />
<br /></p>

<h4 id="重载函数调用运算符函数对象"><strong>重载函数调用运算符（函数对象）</strong></h4>
<p>像使用函数一样使用该类对象</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="n">myAbs</span><span class="p">{</span>
      <span class="kt">int</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">val</span> <span class="o">:</span> <span class="n">val</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myAbs</span><span class="p">()(</span><span class="o">-</span><span class="mi">42</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 42</span>
  <span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 函数对象经常作为泛型算法的实参</span>
  <span class="k">struct</span> <span class="n">printTwice</span><span class="p">{</span>
    <span class="kt">char</span> <span class="n">op</span><span class="p">;</span>
    <span class="n">printTwice</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">)</span><span class="o">:</span> <span class="n">op</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="n">op</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">printTwice</span><span class="p">(</span><span class="sc">','</span><span class="p">)(</span><span class="s">"123"</span><span class="p">);</span>
    <span class="c1">//Output: 123,123</span>

    <span class="n">string</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"abc"</span><span class="p">,</span> <span class="s">"def"</span><span class="p">,</span> <span class="s">"hhh"</span><span class="p">};</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">printTwice</span><span class="p">());</span>
    <span class="c1">//Output:</span>
    <span class="c1">//abc abc</span>
    <span class="c1">//def def</span>
    <span class="c1">//hhh hhh</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="oop-类型转换"><strong>[OOP] 类型转换</strong></h3>
<h4 id="基本类型---类"><strong>基本类型 -&gt; 类</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">myString</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">myString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span>
      <span class="n">myString</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">myString</span><span class="o">::</span><span class="n">myString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
      <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
      <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">myString</span> <span class="n">s1</span><span class="p">;</span>
      <span class="n">s1</span> <span class="o">=</span> <span class="n">myString</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="s">"Apple"</span><span class="p">));</span>  <span class="c1">//从char*类型到myString类型，通过隐式调用构造函数</span>
  <span class="p">}</span>
</code></pre></div></div>
<h4 id="类---基本类型"><strong>类 -&gt; 基本类型</strong></h4>
<p>重载类型转换符函数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//以立方转原来的数为栗子</span>
  <span class="k">class</span> <span class="nc">cube</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">cube</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">res</span><span class="p">(</span><span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
      <span class="k">operator</span> <span class="kt">double</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pow</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="p">;</span> <span class="p">}</span>    <span class="c1">//重载类型转换符</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">double</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">cube</span> <span class="n">num</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="mf">4.0</span><span class="p">));</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="kt">double</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 4</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="类a---类b"><strong>类A -&gt; 类B</strong></h4>
<p>类A转换操作符，类B使用构造函数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//以立方转开方为栗子</span>
  <span class="k">class</span> <span class="nc">square</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">square</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">res</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num</span><span class="p">))</span> <span class="p">{}</span>
      <span class="n">square</span><span class="p">(</span><span class="k">const</span> <span class="n">square</span><span class="o">&amp;</span> <span class="n">obj2</span><span class="p">);</span>   <span class="c1">//复制拷贝函数</span>
      <span class="kt">double</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">double</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">};</span>


  <span class="k">class</span> <span class="nc">cube</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">cube</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">res</span><span class="p">(</span><span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
      <span class="k">operator</span> <span class="n">square</span><span class="p">();</span>    <span class="c1">//重载操作符</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">double</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">};</span>


  <span class="n">cube</span><span class="o">::</span><span class="k">operator</span> <span class="n">square</span><span class="p">(){</span>
      <span class="kt">double</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">square</span><span class="o">::</span><span class="n">square</span><span class="p">(</span><span class="k">const</span> <span class="n">square</span> <span class="o">&amp;</span><span class="n">obj2</span><span class="p">){</span>
      <span class="n">res</span> <span class="o">=</span> <span class="n">obj2</span><span class="p">.</span><span class="n">res</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ---------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">cube</span> <span class="n">num</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="mf">4.0</span><span class="p">));</span>
      <span class="n">square</span> <span class="n">num2</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 2</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="转换为bool"><strong>转换为bool</strong></h4>
<p>使用流对象时都会使用为IO类定义的 operator bool， 如语句 <code class="highlighter-rouge">while(cin &gt;&gt; n)</code> 中， 为了对条件求值，cin被istream operator bool类型转换函数隐式地执行了转换。如果cin.good() == true，则返回真<br />
<br /></p>

<h4 id="显式类型转换运算符"><strong>显式类型转换运算符</strong></h4>
<p><strong>explicit</strong>： 阻止单参数构造函数调用时执行的隐式转换</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">explicit</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">test</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>     <span class="c1">//合法</span>
      <span class="n">test</span> <span class="n">obj2</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>    <span class="c1">//error: conversion from ‘int’ to non-scalar type ‘test’ requested</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>[OJ 填空题]  你真的搞清楚为啥 while(cin » n) 能成立了吗？</strong></p>
<blockquote>
  <p><strong>题目描述</strong></p>
  <blockquote>
    <p>读入两个整数，输出两个整数 ，直到碰到-1</p>
  </blockquote>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">MyCin</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">MyCin</span><span class="p">()</span> <span class="p">{</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
      <span class="n">MyCin</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>    <span class="c1">// 重载运算符 &gt;&gt;，作为输入流因此为类成员</span>
          <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">obj</span><span class="p">;</span>
          <span class="k">if</span><span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>   <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">return</span> <span class="p">(</span><span class="o">*</span> <span class="k">this</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">operator</span> <span class="kt">bool</span><span class="p">(){</span>    <span class="c1">// 重点！ 重载操作符bool，适用于 while(),  if() 等或者显示的 bool()调用转换</span>
          <span class="k">return</span> <span class="n">flag</span><span class="p">;</span>
      <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>   <span class="c1">//标记是否遇到-1</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">MyCin</span> <span class="n">m</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">n1</span> <span class="o">&gt;&gt;</span> <span class="n">n2</span><span class="p">)</span>
          <span class="n">cout</span>  <span class="o">&lt;&lt;</span> <span class="n">n1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">n2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="oop-模板"><strong>[OOP] 模板</strong></h3>
<h4 id="函数模板"><strong>函数模板</strong></h4>
<p>C++提供函数模板简化重载函数的过程<br />
以之前写过的larger函数重载为栗</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>  <span class="c1">//模板语法，T是类型，由传参决定</span>
  <span class="n">T</span> <span class="n">larger</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// -------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">larger</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 7</span>

      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">larger</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: Z</span>

      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">larger</span><span class="p">(</span><span class="mf">9.9999</span><span class="p">,</span> <span class="mf">9.9898</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 9.9999</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>[OJ 填空题]  简单的SumArray</strong></p>
<blockquote>
  <p><strong>输入</strong></p>
  <blockquote>
    <p>无</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>输出</strong></p>
  <blockquote>
    <p>TomJackMaryJohn<br />
10</p>
  </blockquote>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include &lt;iostream&gt;
</span>  <span class="cp">#include &lt;string&gt;
</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">T</span> <span class="n">SumArray</span><span class="p">(</span>

  <span class="c1">// 在此处补充你的代码 ---------------------------</span>
   <span class="n">T</span> <span class="o">*</span> <span class="n">begin</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">end</span><span class="p">){</span>
      <span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="o">*</span> <span class="n">begin</span><span class="p">;</span>
      <span class="n">T</span> <span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">){</span>
          <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="o">*</span> <span class="n">it</span><span class="p">;</span>   <span class="c1">//注意string类重载了+，所以这样子是可以的</span>
          <span class="n">it</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="c1">// -------------------------------------------</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">string</span> <span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"Tom"</span><span class="p">,</span><span class="s">"Jack"</span><span class="p">,</span><span class="s">"Mary"</span><span class="p">,</span><span class="s">"John"</span><span class="p">};</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">SumArray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">array</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>  <span class="c1">//提示：1+2+3+4 = 10</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">SumArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="类模板"><strong>类模板</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>    <span class="c1">//语法需要</span>
  <span class="k">class</span> <span class="nc">point</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">point</span><span class="p">();</span>
      <span class="kt">void</span> <span class="n">setPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">iy</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">display</span><span class="p">()</span>  <span class="k">const</span><span class="p">;</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">T</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="n">point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">point</span><span class="p">(){</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;}</span>   <span class="c1">//注意是point&lt;T&gt;，并且每一处有使用T的地方，前面都要加 template &lt;class T&gt;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">setPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">iy</span><span class="p">){</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ix</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">iy</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">display</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x is "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", y is "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>

  <span class="c1">// -------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">point</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>
      <span class="n">point</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">;</span>
      <span class="n">p1</span><span class="p">.</span><span class="n">setPoint</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
      <span class="n">p2</span><span class="p">.</span><span class="n">setPoint</span><span class="p">(</span><span class="mf">3.1415</span><span class="p">,</span> <span class="mf">2.71</span><span class="p">);</span>

      <span class="n">p1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
      <span class="c1">//Output: x is 5, y is 6</span>

      <span class="n">p2</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
      <span class="c1">//Output: x is 3.1415, y is 2.71</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="带多个参数的类模板和函数模板"><strong>带多个参数的类模板和函数模板</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//类模板</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span>   <span class="c1">//两个参数</span>
  <span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">test</span><span class="p">(</span><span class="n">T1</span> <span class="n">x</span><span class="p">,</span> <span class="n">T2</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" and "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">T1</span> <span class="n">a</span><span class="p">;</span>
      <span class="n">T2</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">test</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">obj1</span><span class="p">(</span><span class="s">"HAhhhhhh"</span><span class="p">,</span> <span class="mf">1.234567</span><span class="p">);</span>
      <span class="n">obj1</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="c1">//Output: HAhhhhhh and 1.23457</span>
  <span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//函数模板</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span>   <span class="c1">//两个参数</span>
  <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">T1</span> <span class="n">x</span><span class="p">,</span> <span class="n">T2</span> <span class="n">y</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" or "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">print</span><span class="p">(</span><span class="s">"emmm"</span><span class="p">,</span> <span class="mi">12580</span><span class="p">);</span>
      <span class="c1">//Output: emmm or 12580</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="无类型模板参数"><strong>无类型模板参数</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">&gt;</span>    <span class="c1">//size作为参数传进去</span>
  <span class="k">class</span> <span class="nc">array</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">array</span><span class="p">()</span> <span class="p">{</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">size</span><span class="p">];</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">T</span><span class="o">*</span> <span class="n">arr</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">array</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">obj1</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="异常处理"><strong>异常处理</strong></h3>
<h4 id="基本概念"><strong>基本概念</strong></h4>
<p>异常分为 <strong>同步异常</strong> 和 <strong>异步异常</strong>， 异步异常指程序控制力之外的事件产生的错误<br />
C++中提出的异常处理机制 <strong>只用来应付同步异常</strong><br />
异常处理机制：</p>
<ol>
  <li>发现异常</li>
  <li>抛出异常</li>
  <li>捕捉异常</li>
  <li>处理异常</li>
</ol>

<p><br /></p>

<h4 id="异常处理机制"><strong>异常处理机制</strong></h4>
<p>C++异常处理机制基本建立在三个关键词上：<code class="highlighter-rouge">try</code>, <code class="highlighter-rouge">throw</code>, <code class="highlighter-rouge">catch</code><br />
<strong>try块</strong>： 块内可能产生错误<br />
<strong>throw语句</strong>： 抛出异常 <br />
<strong>catch块</strong>： 必须紧跟在try块后，捕捉异常<br />
以经典的除0错误举栗子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">try</span><span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a/b = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
      <span class="k">else</span><span class="p">{</span> <span class="k">throw</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="p">}</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Try END"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//发生异常时没有被执行，因为流程从try块中退出，转到catch块中</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Exception caught: b = "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"END"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//仍然执行</span>

  <span class="c1">//Input: 7 1</span>
  <span class="c1">//Output:</span>
  <span class="c1">//a/b = 7</span>
  <span class="c1">//Try END</span>
  <span class="c1">//END</span>

  <span class="c1">//Input: 5 0</span>
  <span class="c1">//Output:</span>
  <span class="c1">//Exception caught: b = 0</span>
  <span class="c1">//END</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="捕捉机制"><strong>捕捉机制</strong></h4>
<p>catch块会捕捉和catch参数类型匹配的异常，捕捉成功则catch块中的代码会被执行<br />
若catch块中的参数有名称，则该参数可用在异常处理的代码中</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>     <span class="k">throw</span> <span class="sc">'a'</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>    <span class="k">throw</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>    <span class="k">throw</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="kt">char</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Catch a Alpha!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Catch a Number!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="kt">double</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Catch a Space!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//Input: z</span>
    <span class="c1">//Output: Catch a Alpha!</span>

    <span class="c1">//Input: 5</span>
    <span class="c1">//Output: Catch a Number!</span>

    <span class="c1">//Input: (空格，打出来你也看不见)</span>
    <span class="c1">//Output: Catch a Space!</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="重新抛出异常"><strong>重新抛出异常</strong></h4>
<p>直接调用throw即可，无需任何参数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="n">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
      <span class="k">try</span><span class="p">{</span>
          <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x/y = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">/</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
          <span class="k">else</span><span class="p">{</span> <span class="k">throw</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">catch</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Divide ERROR!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
          <span class="k">throw</span><span class="p">;</span>  <span class="c1">//重新抛出</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">;</span>
      <span class="k">try</span><span class="p">{</span>
          <span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">catch</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>     <span class="c1">//捕捉重新抛出的错误</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Function ERROR!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">//Input:8 0</span>
      <span class="c1">//Output:</span>
      <span class="c1">//Divide ERROR!</span>
      <span class="c1">//Function ERROR!</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="指定异常"><strong>指定异常</strong></h4>
<p>C++11反对，故不写<br />
<br /></p>

<h3 id="标准模板库stl"><strong>标准模板库(STL)</strong></h3>
<h4 id="容器"><strong>容器</strong></h4>
<ul>
  <li><strong>线性容器</strong> ： vector, list, deque</li>
  <li><strong>关联式容器</strong> ： set, multiset, map, multimap</li>
  <li><strong>衍生容器</strong> ： stack, queue, priority-queue</li>
</ul>

<p><img src="http://houzajblog-1252277898.coscd.myqcloud.com/20180108%20CPP/1.jpg" alt="容器1" /><br />
<img src="http://houzajblog-1252277898.coscd.myqcloud.com/20180108%20CPP/2.jpg" alt="容器2" /> <br />
<br /></p>

<h4 id="算法"><strong>算法</strong></h4>
<p><img src="http://houzajblog-1252277898.coscd.myqcloud.com/20180108%20CPP/3.jpg" alt="算法1" /><br />
<img src="http://houzajblog-1252277898.coscd.myqcloud.com/20180108%20CPP/4.jpg" alt="算法2" /> <br />
<br /></p>

<h4 id="迭代器"><strong>迭代器</strong></h4>
<p>（这部分内容直接copy数据结构那篇文写的）<br />
为了简化迭代器的开发和基于迭代器的通用算法的分类，C++的STL定义了5种迭代器：</p>
<ol>
  <li><strong>输入</strong>: 提供对其指向元素的只读操作，具有 前置++, 后置++ 等操作符</li>
  <li><strong>输出</strong>: 提供对其指向元素的写操作，具有 前置++, 后置++ 等操作符</li>
  <li><strong>向前</strong>: 具有++操作符</li>
  <li><strong>双向</strong>: 具有++, –操作符</li>
  <li><strong>随机访问</strong>: 最一般的迭代器，可随意实现跳跃移动，也可通过指针算术运算实现移动，但sort不支持<br />
<br /></li>
</ol>

<h4 id="函数对象"><strong>函数对象</strong></h4>
<p><img src="http://houzajblog-1252277898.coscd.myqcloud.com/20180108%20CPP/5.jpg" alt="函数对象" /></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//比如在sort中</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">N</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>    <span class="c1">//降序排序</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="标准模板库stl的应用"><strong>标准模板库(STL)的应用</strong></h3>
<h4 id="string"><strong>string</strong></h4>
<p><strong>[OJ题]  H04:字符串操作</strong></p>
<blockquote>
  <p><strong>描述</strong></p>
  <blockquote>
    <p>给定n个字符串（从1开始编号），每个字符串中的字符位置从0开始编号，长度为1-500，现有如下若干操作：</p>

    <p>copy N X L：取出第N个字符串第X个字符开始的长度为L的字符串。<br />
add S1 S2：判断S1，S2是否为0-99999之间的整数，若是则将其转化为整数做加法，若不是，则作字符串加法，返回的值为一字符串。<br />
find S N：在第N个字符串中从左开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。<br />
rfind S N：在第N个字符串中从右开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。<br />
insert S N X：在第N个字符串的第X个字符位置中插入S字符串。<br />
reset S N：将第N个字符串变为S。<br />
print N：打印输出第N个字符串。<br />
printall：打印输出所有字符串。<br />
over：结束操作。</p>

    <p>其中N，X，L可由find与rfind操作表达式构成，S，S1，S2可由copy与add操作表达式构成。</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>输入</strong></p>
  <blockquote>
    <p>第一行为一个整数n（n在1-20之间）<br />
接下来n行为n个字符串，字符串不包含空格及操作命令等。<br />
接下来若干行为一系列操作，直到over结束。</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>输出</strong></p>
  <blockquote>
    <p>根据操作提示输出对应字符串。</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>样例输入</strong></p>
  <blockquote>
    <p>3<br />
329strjvc<br />
Opadfk48<br />
Ifjoqwoqejr<br />
insert copy 1 find 2 1 2 2 2<br />
print 2<br />
reset add copy 1 find 3 1 3 copy 2 find 2 2 2 3<br />
print 3<br />
insert a 3 2<br />
printall<br />
over</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>样例输出</strong></p>
  <blockquote>
    <p>Op29adfk48<br />
358<br />
329strjvc<br />
Op29adfk48<br />
35a8</p>
  </blockquote>
</blockquote>

<p>本题用string类中的操作特别方便，故我将本题作为string类的应用题放在这儿 <br />
看完题目后，会发现本题的难点在于 S，S1，S2 和 N，X，L 不一定直接给出，可能通过调用函数获得，所以我们可以考虑 <strong>将获取n，x，l作为一个函数，获取s，s1,s2作为另一个函数</strong>， 调用这两个函数，而函数内又可判断是否继续调用别的函数获取所需值，这样处理就会方便很多</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include &lt;iostream&gt;
</span>    <span class="cp">#include &lt;cctype&gt;
</span>    <span class="cp">#include &lt;cstdlib&gt;
</span>    <span class="cp">#include &lt;vector&gt;
</span>    <span class="cp">#include &lt;sstream&gt;
</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">myString</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">myString</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">pvec</span><span class="p">)</span><span class="o">:</span> <span class="n">vec</span><span class="p">(</span><span class="n">pvec</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vec</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">string</span><span class="p">(</span><span class="s">"none"</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">op</span><span class="p">();</span>            <span class="c1">//对外调用接口，每一行指令调用一次op()，指令为over时返回false</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

        <span class="kt">void</span> <span class="n">insert</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">reset</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">printall</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">find</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">rfind</span><span class="p">();</span>
        <span class="n">string</span> <span class="n">copy</span><span class="p">();</span>
        <span class="n">string</span> <span class="n">add</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">getNXL</span><span class="p">();</span>         <span class="c1">//获取n，x，l</span>
        <span class="n">string</span> <span class="n">getS</span><span class="p">();</span>        <span class="c1">//获取s</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">myString</span><span class="o">::</span><span class="n">getNXL</span><span class="p">(){</span>
        <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"find"</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">find</span><span class="p">();</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"rfind"</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">rfind</span><span class="p">();</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">atoi</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>   <span class="c1">//str.c_str():返回char*型字符串</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">string</span> <span class="n">myString</span><span class="o">::</span><span class="n">getS</span><span class="p">(){</span>
        <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"copy"</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">copy</span><span class="p">();</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"add"</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">add</span><span class="p">();</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">myString</span><span class="o">::</span><span class="n">insert</span><span class="p">(){</span>
        <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">getS</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">();</span>
        <span class="n">vec</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>    <span class="c1">//vec[n].insert(x, s)：在第x的位置插入元素s</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">myString</span><span class="o">::</span><span class="n">reset</span><span class="p">(){</span>
        <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">getS</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">();</span>
        <span class="n">vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">myString</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">myString</span><span class="o">::</span><span class="n">printall</span><span class="p">(){</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  <span class="c1">//迭代器，可看作指针</span>
        <span class="n">it</span><span class="o">++</span><span class="p">;</span>                                       <span class="c1">//第一个是“none”故需++</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span> <span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">myString</span><span class="o">::</span><span class="n">find</span><span class="p">(){</span>
        <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">getS</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">();</span>
        <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>  <span class="c1">//str.find(s): 正向查找子串s第一次出现的位置，失败返回npos</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">){</span>        <span class="c1">//string::npos: find(), rfind() 失败返回npos</span>
            <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>            <span class="c1">//s.size(): 返回s的长度,也可写作s.length()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">myString</span><span class="o">::</span><span class="n">rfind</span><span class="p">(){</span>
        <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">getS</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">();</span>
        <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span> <span class="c1">//str.rfind(s):逆向查找子串s第一次出现的位置，失败返回npos</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">string</span> <span class="n">myString</span><span class="o">::</span><span class="n">copy</span><span class="p">(){</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">(),</span> <span class="n">x</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">(),</span> <span class="n">l</span> <span class="o">=</span> <span class="n">getNXL</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">vec</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">substr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>     <span class="c1">//str.substr(x, l):返回str的子串，该子串为str的第x个字符开始长度为l的字符串</span>
    <span class="p">}</span>

    <span class="n">string</span> <span class="n">myString</span><span class="o">::</span><span class="n">add</span><span class="p">(){</span>
        <span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>      <span class="c1">//使用stringstream实现类型转换</span>
        <span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">getS</span><span class="p">(),</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">getS</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">c_str</span><span class="p">()),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">s2</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

        <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">'0'</span> <span class="o">||</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">){</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">'0'</span> <span class="o">||</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">){</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">99999</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">99999</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="p">){</span>
            <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
            <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
            <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">myString</span><span class="o">::</span><span class="n">op</span><span class="p">(){</span>
        <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"over"</span><span class="p">)</span>           <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"copy"</span><span class="p">)</span>      <span class="n">copy</span><span class="p">();</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"add"</span><span class="p">)</span>       <span class="n">add</span><span class="p">();</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"find"</span><span class="p">)</span>      <span class="n">find</span><span class="p">();</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"rfind"</span><span class="p">)</span>     <span class="n">rfind</span><span class="p">();</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"insert"</span><span class="p">)</span>    <span class="n">insert</span><span class="p">();</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"reset"</span><span class="p">)</span>     <span class="n">reset</span><span class="p">();</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"print"</span><span class="p">)</span>     <span class="n">print</span><span class="p">();</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"printall"</span><span class="p">)</span>  <span class="n">printall</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ------------------------------</span>

    <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="o">--</span><span class="p">){</span>
            <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>
            <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">myString</span> <span class="n">obj</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">op</span><span class="p">());</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<h4 id="map"><strong>map</strong></h4>
<p><strong>[OJ题]  H06:冷血格斗场</strong></p>
<blockquote>
  <p><strong>描述</strong></p>
  <blockquote>
    <p>为了迎接08年的奥运会，让大家更加了解各种格斗运动，facer新开了一家冷血格斗场。格斗场实行会员制，但是新来的会员不需要交入会费，而只要同一名老会员打一场表演赛，证明自己的实力。<br />
我们假设格斗的实力可以用一个正整数表示，成为实力值，两人的实力值可以相同。另外，每个人都有一个唯一的id，也是一个正整数。为了使得比赛更好看，每一个新队员都会选择与他实力最为接近的人比赛，即比赛双方的实力值之差的绝对值越小越好，如果有多个人的实力值与他差别相同，则他会选择id最小的那个。<br />
不幸的是，Facer一不小心把比赛记录弄丢了，但是他还保留着会员的注册记录。现在请你帮facer恢复比赛纪录，按照时间顺序依次输出每场比赛双方的id。</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>输入</strong></p>
  <blockquote>
    <p>第一行一个数n(0 &lt; n &lt;=100000)，表示格斗场新来的会员数（不包括facer）。以后n行每一行两个数，按照入会的时间给出会员的id和实力值。一开始，facer就算是会员，id为1，实力值1000000000。</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>输出</strong></p>
  <blockquote>
    <p>N行，每行两个数，为每场比赛双方的id，新手的id写在前面。</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>样例输入</strong></p>
  <blockquote>
    <p>3<br />
2 3<br />
3 1<br />
4 2</p>
  </blockquote>
</blockquote>

<blockquote>
  <p><strong>样例输出</strong></p>
  <blockquote>
    <p>2 1<br />
3 2<br />
4 2</p>
  </blockquote>
</blockquote>

<p><strong>map内部由二叉树（红黑树）封装而成，数据默认按照key值升序排序，插入和查找操作时间复杂度都为O(logN)</strong><br />
本题使用map是因为根据题意，需要按实力值排序，并且需要不断进行插入和查找操作，而给的数据比较大，所以使用map作为存储结构<br />
另外，本题的难点为，若按实力值排序，而map只能单一key对应单一value，而可能有不同id的人拥有相同的实力值，但考虑到每次都选择id最小的人作为对手，因此每次输入数据时可检测是否存在该key，若存在则当id小于该key时替换该key即可</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include &lt;bits/stdc++.h&gt;
</span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
      <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">,</span> <span class="n">it_before</span><span class="p">,</span> <span class="n">it_after</span><span class="p">;</span>
      <span class="n">mp</span><span class="p">[</span><span class="mi">1000000000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="o">--</span><span class="p">){</span>
          <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ans_id</span><span class="p">;</span>
          <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>

          <span class="n">it</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
          <span class="k">if</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>       <span class="c1">//若找到，则替换为id更小的</span>
              <span class="n">ans_id</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
              <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
          <span class="p">}</span><span class="k">else</span><span class="p">{</span>
              <span class="n">mp</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
              <span class="n">it</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
              <span class="n">it_before</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">//取it前一个的迭代器</span>
              <span class="n">it_after</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>     <span class="c1">//取it后一个的迭代器</span>


              <span class="k">if</span><span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">mp</span><span class="p">.</span><span class="n">begin</span><span class="p">()){</span>
                  <span class="n">ans_id</span> <span class="o">=</span> <span class="n">it_after</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
              <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
                  <span class="n">ans_id</span> <span class="o">=</span> <span class="n">it_before</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
              <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">it_after</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">-</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">-</span> <span class="n">it_before</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">){</span>
                  <span class="n">ans_id</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">it_before</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">it_after</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
              <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                  <span class="n">ans_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">it_after</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">-</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">-</span> <span class="n">it_before</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="o">?</span> <span class="n">it_after</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">:</span> <span class="n">it_before</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">ans_id</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

      <span class="p">}</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

    </article>
    
</div>

<section class="author-detail">
    <section class="post-footer-item author-card">
        <div class="avatar">
            <img src="http://localhost:4000/assets/img/profile.png" alt="">
        </div>
        <div class="author-name" rel="author">HouZAJ</div>
        <div class="bio">
            <p>A developing developer & terrible designer!</p>
        </div>
        
    </section>
    <section class="post-footer-item read-next">
        
        
        <div class="read-next-item">
            <a href="/2018/03/10/20180310_Problems.html" class="read-next-link"></a>
            <section>
                <span>刷题记 —— 2018.3.10</span>
                <p>  扩展欧几里德  |  CodeForces 898B， CodeForces 599B</p>
            </section>
            
            <div class="filter"></div>
            <img src="http://houzajblog-1252277898.coscd.myqcloud.com/20180310%20Problem0310/20180309-01.png" alt="">
            
        </div>
        
    </section>
    
</section>

<footer class="g-footer">
    <section>HouZAJ Blog © 2018</section>
    <section>Powered by <a href="//jekyllrb.com">Jekyll</a> | <a href="https://github.com/kaeyleo/jekyll-theme-H2O">Modified from Theme H2O, the author is liaokeyu</a></section>
</footer>


<script src="/assets/js/social-share.min.js"></script>
<script>
    socialShare('.social-share', {
        sites: ['wechat','weibo','github'],
        wechatQrcodeTitle: "分享到微信朋友圈",
        wechatQrcodeHelper: '<p>扫码后点击右上角</p><p>将本文分享至朋友圈</p>'
    });
</script>
<script data-cfasync=false>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
/*写入自己的disqus信息*/
s.src = 'https://liaokeyu.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<script data-cfasync=false src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
<script data-cfasync=false src="https://cdn.bootcss.com/clipboard.js/1.7.1/clipboard.js"></script>
<script data-cfasync=false src="/assets/js/prism.js"></script>
<script data-cfasync=false src="/assets/js/index.min.js"></script>
</body>
</html>
