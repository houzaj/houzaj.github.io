<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>学习笔记 - C++ - HouZAJ Blog</title>
    <meta name="author"  content="HouZAJ">
    <meta name="description" content="学习笔记 - C++">
    <meta name="keywords"  content="Programming">
    <!-- Open Graph -->
    <meta property="og:title" content="学习笔记 - C++ - HouZAJ Blog">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://localhost:4000/2018/01/08/cpp_summary.html">
    <meta property="og:description" content="A emmmmmmm developer">
    <meta property="og:site_name" content="HouZAJ Blog">
    <link rel="stylesheet" href="//cdn.staticfile.org/normalize/6.0.0/normalize.min.css">
    <link rel="stylesheet" href="/assets/css/github-markdown.css">
    <link href="/assets/css/prism.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/share.min.css">
    <link rel="stylesheet" href="/assets/css/app.min.css">
</head>

<body>
    <!--[if lt IE 10]>
<div class="alert-danger" role="alert">你的浏览器实在太太太旧了，放学别走，升级完浏览器再说！<a target="_blank" class="alert-link" href="http://browsehappy.com">立即升级</a></div>
<![endif]-->
<input id="nm-switch" type="hidden" value="false">

<header class="g-header">
    <i id="menu-toggle" class="iconfont icon-menu"></i>
    <nav class="g-nav">
        <ul>
            
            <li><a href="/">home</a></li>
            
            <li><a href="/tags.html">sorts</a></li>
            
        </ul>
    </nav>
</header>


<header class="g-banner post-header post-pattern-circuitBoard bgcolor-default " data-theme="default">
    <div class="post-wrapper">
        <div class="post-tags">
            
            
            <a href="http://localhost:4000/tags#Programming" class="post-tag">Programming</a>
            
            
        </div>
        <h1>学习笔记 - C++</h1>
        <div class="post-meta">
            <span class="post-meta-item"><i class="iconfont icon-author"></i><a href="http://localhost:4000" target="_blank" rel="author">HouZAJ</a></></span>
            <time class="post-meta-item" datetime="18-01-08"><i class="iconfont icon-date"></i>08 Jan 2018</time>
        </div>
    </div>
    
    <div class="filter"></div>
    <div class="post-cover" style="background: url('') center no-repeat; background-size: cover;">
    
</header>

<div class="post-content">
    
    <article class="markdown-body">
        <blockquote>
  <p>好好学习哈哈哈哈哈哈哈</p>
</blockquote>

<p><br /></p>

<iframe type="text/html" src="http://music.163.com/outchain/player?type=2&amp;id=33418878&amp;auto=0&amp;height=66" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86"></iframe>

<p><br /></p>

<blockquote>
  <p>目录</p>
</blockquote>

<ul id="markdown-toc">
  <li><a href="#part-i---前言" id="markdown-toc-part-i---前言">PART I - 前言</a></li>
  <li><a href="#part-ii---笔记" id="markdown-toc-part-ii---笔记">PART II - 笔记</a>    <ul>
      <li><a href="#-零散点" id="markdown-toc--零散点">▲ 零散点</a>        <ul>
          <li><a href="#c的强制类型转换" id="markdown-toc-c的强制类型转换"><strong>C++的强制类型转换</strong></a></li>
          <li><a href="#cin-cout" id="markdown-toc-cin-cout"><strong>cin cout</strong></a></li>
          <li><a href="#文件输入输出" id="markdown-toc-文件输入输出"><strong>文件输入/输出</strong></a></li>
          <li><a href="#bool数据类型" id="markdown-toc-bool数据类型"><strong>bool数据类型</strong></a></li>
          <li><a href="#assert函数" id="markdown-toc-assert函数"><strong>assert函数</strong></a></li>
          <li><a href="#eof函数" id="markdown-toc-eof函数"><strong>eof函数</strong></a></li>
          <li><a href="#内联函数" id="markdown-toc-内联函数"><strong>内联函数</strong></a></li>
          <li><a href="#引用参数" id="markdown-toc-引用参数"><strong>引用参数</strong></a></li>
          <li><a href="#全局变量的副作用" id="markdown-toc-全局变量的副作用"><strong>全局变量的副作用</strong></a></li>
          <li><a href="#函数重载" id="markdown-toc-函数重载"><strong>函数重载</strong></a></li>
          <li><a href="#typedef语句" id="markdown-toc-typedef语句"><strong>typedef语句</strong></a></li>
          <li><a href="#namespace名字空间" id="markdown-toc-namespace名字空间"><strong>namespace(名字空间)</strong></a></li>
          <li><a href="#string数据类型" id="markdown-toc-string数据类型"><strong>string数据类型</strong></a></li>
          <li><a href="#定义二维数组的另一种方法" id="markdown-toc-定义二维数组的另一种方法"><strong>定义二维数组的另一种方法</strong></a></li>
          <li><a href="#头文件的包含和多重包含" id="markdown-toc-头文件的包含和多重包含"><strong>头文件的包含和多重包含</strong></a></li>
        </ul>
      </li>
      <li><a href="#oop" id="markdown-toc-oop">▲OOP</a>        <ul>
          <li><a href="#类" id="markdown-toc-类"><strong>类</strong></a></li>
          <li><a href="#构造函数" id="markdown-toc-构造函数"><strong>构造函数</strong></a></li>
          <li><a href="#抽象数据类型abstract-data-type-adt" id="markdown-toc-抽象数据类型abstract-data-type-adt"><strong>抽象数据类型(Abstract data type, ADT)</strong></a></li>
          <li><a href="#继承is-a关系" id="markdown-toc-继承is-a关系"><strong>继承(“is-a”关系)</strong></a></li>
          <li><a href="#组成has-a关系" id="markdown-toc-组成has-a关系"><strong>组成(“has-a”关系)</strong></a></li>
          <li><a href="#ood面向对象程序设计-和-oop面向对象编程" id="markdown-toc-ood面向对象程序设计-和-oop面向对象编程"><strong>OOD(面向对象程序设计) 和 OOP(面向对象编程)</strong></a></li>
          <li><a href="#纯虚函数" id="markdown-toc-纯虚函数"><strong>纯虚函数</strong></a></li>
          <li><a href="#虚函数" id="markdown-toc-虚函数"><strong>虚函数</strong></a></li>
          <li><a href="#类型转换" id="markdown-toc-类型转换"><strong>类型转换</strong></a></li>
          <li><a href="#重载" id="markdown-toc-重载"><strong>重载</strong></a></li>
          <li><a href="#模板" id="markdown-toc-模板"><strong>模板</strong></a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>
<h2 id="part-i---前言">PART I - 前言</h2>
<p>之前C++只啃了一点很基础的东西和学了些STL的用法方便打代码哈哈哈，然后期末还是没用到 _(:з」∠)_<br />
参考：</p>
<ol>
  <li>C++ Programming – Program Design Including Data Structures</li>
  <li>Data Structures, Algorithms, and Applications in C++</li>
  <li>Object Oriented Programming with C++ (Fourth Edition)</li>
</ol>

<p><br /></p>
<h2 id="part-ii---笔记">PART II - 笔记</h2>
<h3 id="-零散点">▲ 零散点</h3>
<h4 id="c的强制类型转换"><strong>C++的强制类型转换</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">7.9</span> <span class="o">+</span> <span class="mf">6.7</span><span class="p">);</span>    <span class="c1">//14</span>
  <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">65</span><span class="p">);</span>    <span class="c1">//A</span>
</code></pre></div></div>

<h4 id="cin-cout"><strong>cin cout</strong></h4>
<ul>
  <li><strong>变量定义</strong><br />
头文件iostream中包含cin、cout的变量定义
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">istream</span> <span class="n">cin</span><span class="p">;</span>
<span class="n">ostream</span> <span class="n">cout</span><span class="p">;</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>读取有关函数</strong> <br />
get、ignore、putback、peek函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//读取一个字符存到ch中，空格、回车均可存     </span>
<span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>  
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//忽略掉下面100个字符 或者 忽略掉下个'\n'之前的所有字符   </span>
<span class="n">cin</span><span class="p">.</span><span class="n">ignore</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">);</span>   
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//把ch变量退回输入流中    </span>
<span class="n">cin</span><span class="p">.</span><span class="n">putback</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//检测下一个字符为何值</span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">cin</span><span class="p">.</span><span class="n">peek</span><span class="p">();</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>输入失败</strong> <br />
类型不匹配导致输入失败时（如将小数点’.’读入int型变量中），输入流会处于Fail State（错误状态），接下来使用该输入流的所有I/O语句都将被忽略掉，使用clear()函数可使其恢复到正常状态。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使cin流恢复正常状态</span>
<span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>格式化输出</strong>
    <ul>
      <li><strong>头文件</strong><br />
需包含头文件iomanip</li>
      <li><strong>fixed, scientific, showpoint, setprecision</strong>
        <ul>
          <li><code class="highlighter-rouge">setprecision(n)</code> : 将输出的小数点指定为n位，一次设置，永久生效，直到下一个setprecision(n)覆盖设置</li>
          <li><code class="highlighter-rouge">fixed</code> : 固定小数点形式</li>
          <li><code class="highlighter-rouge">showpoint</code> : 强制显示输出数字的小数点和小数点后面的0</li>
          <li><code class="highlighter-rouge">scientific</code> : 以科学计数法形式输出</li>
        </ul>

        <p>在标准C++的环境下，需要通过setf函数或者setiosflags函数控制符两种方式来使用</p>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/*
      第一种方式：最常见方式
      cout &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(2);
  */</span>
  <span class="cm">/*
      第二种方式：使用流函数来指定fixed, scientific, showpoint
      cout.setf(ios::fixed, ios::floatfield);
      cout.setf(ios::showpoint);
      cout &lt;&lt; setprecision(2);
  */</span>
  <span class="cm">/*
      第三种方式：使用setiosflags控制符
      cout &lt;&lt; setiosflags(ios::fixed | ios::showpoint);
      cout &lt;&lt; setprecision(2);
  */</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">1.234</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>      <span class="c1">//1.23</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">123456.0</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">//123456.00</span>
</code></pre></div>        </div>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">scientific</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">123456.0</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">//1.234560e+05</span>
</code></pre></div>        </div>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//取消fixed</span>
  <span class="n">cout</span><span class="p">.</span><span class="n">unsetf</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">fixed</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
      <li><strong>setw, fill, setfill</strong>
        <ul>
          <li><code class="highlighter-rouge">setw(n)</code> : 设置域宽为n</li>
          <li><code class="highlighter-rouge">fill</code> : 全局设置填充字符</li>
          <li><code class="highlighter-rouge">setfill</code> : 当前输出语句设置填充字符</li>
        </ul>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cout</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="sc">'*'</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">setfill</span><span class="p">(</span><span class="sc">'#'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//****1####2</span>
</code></pre></div>        </div>
      </li>
      <li><strong>setw, fill, setfill</strong><br />
顾名思义，左右对齐。下面以left举例，right可同理。
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/*
    第一种方式：最常见方式
    cout &lt;&lt; left;
  */</span>
  <span class="cm">/*
    第二种方式：使用流函数
    cout.setf(ios::left, ios::adjustfield);
  */</span>
  <span class="cm">/*
    第三种方式：使用setiosflags控制符
    cout &lt;&lt; setiosflags(ios::left);
  */</span>
</code></pre></div>        </div>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//取消left</span>
  <span class="n">cout</span><span class="p">.</span><span class="n">unsetf</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">left</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>endl, flush</strong><br />
 endl会将光标移到下一行开头(‘\n’)，并清空缓冲区(相当于执行flush)函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">//即使缓冲区的数据没有存满也可以显示提示信息</span>
   <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter an intger:"</span> <span class="o">&lt;&lt;</span> <span class="n">flush</span><span class="p">;</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>
<h4 id="文件输入输出"><strong>文件输入/输出</strong></h4>
<p>恕我直言，OJ生成随机数据常用……<br />
大致模板如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 声明流变量</span>
  <span class="n">ifstream</span> <span class="n">inData</span><span class="p">;</span>
  <span class="n">ofstream</span> <span class="n">outData</span><span class="p">;</span>

  <span class="c1">// 打开文件</span>
  <span class="n">inData</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"xxx"</span><span class="p">);</span>
  <span class="n">outData</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"xxx"</span><span class="p">);</span>

  <span class="p">{</span>
     <span class="c1">// Do Something</span>
     <span class="c1">//把inData当作cin， outData当作cout使用，同文本重定向操作</span>
  <span class="p">}</span>

  <span class="c1">// 关闭文件</span>
  <span class="n">inData</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
  <span class="n">outData</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</code></pre></div></div>
<p>可把inData改为cin，outData改为cout，这样就直接变成文本重定向 <br />
<br /></p>
<h4 id="bool数据类型"><strong>bool数据类型</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">bool</span> <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">//相当于 = 1</span>
  <span class="kt">bool</span> <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//相当于 = 0</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="assert函数"><strong>assert函数</strong></h4>
<p>终止程序执行，指出发生错误的表达式，包含错误源代码的文件名等，对提高代码质量起很大作用<br />
需包含头文件cassert或assert.h</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//输出：test3: ../test3/main.cpp:6: int main(): Assertion `b' failed.</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//输出：test3: ../test3/main.cpp:6: int main(): Assertion `b &gt; 0' failed.</span>
</code></pre></div></div>
<p>另外，可在预处理指令<code class="highlighter-rouge">#include &lt;cassert&gt;</code>前加入<code class="highlighter-rouge">#define NDEBUG</code>取消所有assert语句 <br />
<br /></p>
<h4 id="eof函数"><strong>eof函数</strong></h4>
<p>检测输入流变量是否遇到了文件结束标志<br />
在遇到文件结束标志时返回true，否则返回false</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">cin</span><span class="p">.</span><span class="n">eof</span><span class="p">()){</span>
    <span class="c1">//Do Something</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="内联函数"><strong>内联函数</strong></h4>
<p>当其被调用时，代码将逐行展开，类似于宏展开</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kr">inline</span> <span class="kt">double</span> <span class="n">cube</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">){</span>   <span class="c1">//关键字inline</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="引用参数"><strong>引用参数</strong></h4>
<p>引用参数接受实参的内存地址，因此在以下三种情况中十分适用：</p>
<ol>
  <li>要从参数中返回多一个值，如<code class="highlighter-rouge">扩展欧几里德算法</code>：
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">extgcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">){</span>
   <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
   <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
     <span class="n">d</span> <span class="o">=</span> <span class="n">extgcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
     <span class="n">y</span> <span class="o">-=</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
   <span class="p">}</span><span class="k">else</span><span class="p">{</span>
     <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
     <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>实参值本身需要改动，如<code class="highlighter-rouge">交换函数</code>：
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
 <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
 <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
 <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>传递地址可以节省拷贝大量数据所需的内存空间和时间</li>
</ol>

<p><br /></p>
<h4 id="全局变量的副作用"><strong>全局变量的副作用</strong></h4>
<p>若多个函数都使用到某个全局变量，一旦出现差错，就很难发现是由哪个函数引起的<br />
在某个部分引起全局变量错误，易误以为是由另一部分引起的。<br />
<br /></p>
<h4 id="函数重载"><strong>函数重载</strong></h4>
<p>函数重载为多个函数使用同个名字，每个函数必须有不同的行参列表</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//可用函数larger判断两个int, char, double, string型变量的最大值，使用时无需使用四个函数，只需larger这一个函数</span>
  <span class="kt">int</span> <span class="nf">larger</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;}</span>
  <span class="kt">char</span> <span class="nf">larger</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">char</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;}</span>
  <span class="kt">double</span> <span class="nf">larger</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;}</span>
  <span class="n">string</span> <span class="nf">larger</span><span class="p">(</span><span class="n">string</span> <span class="n">x</span><span class="p">,</span> <span class="n">string</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="c1">//Do Something</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br />
<strong>枚举类型</strong><br />
略<br />
<br /></p>
<h4 id="typedef语句"><strong>typedef语句</strong></h4>
<p>创建已定义数据类型别名，常用来简化数据类型名</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ull</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">ull</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ll</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="namespace名字空间"><strong>namespace(名字空间)</strong></h4>
<p>ANSI/ISO标准C++试图用namespace来解决全局标识符名字重复的问题</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">namespace</span> <span class="n">temp</span><span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">temp</span><span class="p">;</span>   <span class="c1">//简化使用所有该namespace成员的语法</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//简化使用</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//简化使用</span>
  <span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">namespace</span> <span class="n">temp</span><span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">using</span> <span class="n">temp</span><span class="o">::</span><span class="n">a</span><span class="p">;</span>   <span class="c1">//简化使用某个该namespace成员的语法</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//简化使用</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span><span class="o">::</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="string数据类型"><strong>string数据类型</strong></h4>
<p>string是C++的字符串，比起C语言中用字符数组那是简单得多，具体语法如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">str_sub</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>

  <span class="n">string</span> <span class="n">str3</span> <span class="o">=</span> <span class="n">str1</span> <span class="o">+</span> <span class="sc">' '</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>  <span class="c1">//str3 == "Hello World"</span>
  <span class="n">str3</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'w'</span><span class="p">;</span>  <span class="c1">//可用下标访问与修改, str3 == "Hello world"</span>
  <span class="n">len</span> <span class="o">=</span> <span class="n">str3</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>  <span class="c1">//获取长度，也可用str3.size();</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="n">str3</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"or"</span><span class="p">);</span>  <span class="c1">//查找子串，失败返回npos</span>
  <span class="n">str_sub</span> <span class="o">=</span> <span class="n">str3</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">//返回子串，6为开始位置，5为长度，str_sub == "world"</span>
  <span class="n">str1</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>  <span class="c1">//交换子串， str1 == "World", str2 == "Hello"  </span>
</code></pre></div></div>
<p><br /></p>
<h4 id="定义二维数组的另一种方法"><strong>定义二维数组的另一种方法</strong></h4>
<p>先用typedef定义一个二位数组数据类型，然后用该类型来定义数组</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">const</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">tableType</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>
  <span class="n">tableType</span> <span class="n">matrix</span><span class="p">;</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="头文件的包含和多重包含"><strong>头文件的包含和多重包含</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include &lt;iostream&gt;   //系统提供的头文件用 &lt; &gt;
</span>  <span class="cp">#include "myHeaderFile.h"   //用户定义的用 " "
</span></code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//写头文件时使用以下格式可避免多重包含变量导致编译错误</span>
  <span class="c1">//Header file</span>
  <span class="cp">#ifndef H_test    //if not define，第二次包含时已经define就会跳过下面的代码
</span>  <span class="cp">#define H_test
</span>    <span class="c1">//Do Something</span>
  <span class="cp">#endif
</span></code></pre></div></div>
<p><br /></p>

<h3 id="oop">▲OOP</h3>
<h4 id="类"><strong>类</strong></h4>
<ul>
  <li><strong>类定义</strong><br />
如定义clockType类
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">setTime</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">getTime</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">printTime</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>    <span class="c1">//const说明不能修改clockType类型的成员变量</span>
    <span class="kt">void</span> <span class="n">incrementSeconds</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">incrementMinutes</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">incrementHours</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">equalTime</span><span class="p">(</span><span class="k">const</span> <span class="n">clockType</span><span class="o">&amp;</span> <span class="n">otherClock</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>    <span class="c1">//传引用可提高性能（因为无需拷贝）</span>
<span class="k">private</span><span class="o">:</span>      <span class="c1">//私有成员不能被类外部访问</span>
    <span class="kt">int</span> <span class="n">hr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>    </div>
    <p>另外注意：</p>
    <ol>
      <li>不能在变量定义时同时初始化</li>
      <li>类成员函数在类内一般只用函数原型定义，因为如果在类中提供函数原型，会导致类定义变长，以至于难以理解，同时与信息隐藏有关，当函数定义于类内时，会变为inline函数，所有内联函数的限制和局限也适用于此，故只有小函数才定义在类的定义内</li>
    </ol>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>成员函数实现</strong><br />
以setTime函数为栗子
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">clockType</span><span class="o">::</span><span class="n">setTime</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">){</span>
    <span class="n">hr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">hours</span> <span class="o">&amp;&amp;</span> <span class="n">hours</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">?</span><span class="n">hours</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">minutes</span> <span class="o">&amp;&amp;</span> <span class="n">minutes</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">minutes</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">seconds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">seconds</span> <span class="o">&amp;&amp;</span> <span class="n">seconds</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">seconds</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>类公有成员(public) 和 私有成员(private)， 受保护成员(protected)</strong>  <br />
类成员分为：<code class="highlighter-rouge">公有成员(public)</code>，<code class="highlighter-rouge"> 私有成员(private)</code>， <code class="highlighter-rouge">受保护成员(protected)</code> (protected成员在后面！) <br />
类中默认成员声明为私有成员，故上述类定义可写为：
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">hr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">setTime</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">getTime</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">printTime</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">incrementSeconds</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">incrementMinutes</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">incrementHours</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">equalTime</span><span class="p">(</span><span class="k">const</span> <span class="n">clockType</span><span class="o">&amp;</span> <span class="n">otherClock</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>静态数据成员</strong><br />
特点：
    <ol>
      <li>类的第一个对象被创建时，一次性被初始化为0</li>
      <li>所有实例共享一个静态成员变量</li>
      <li>只在类内可见</li>
      <li>生存期为程序整个执行期</li>
      <li>每个静态成员变量的类型和作用域，都定义于类的定义之外，与类关联但和对象没有关系</li>
      <li>声明于类内，定义于源文件内</li>
    </ol>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">test</span><span class="o">::</span><span class="n">a</span><span class="p">;</span>  <span class="c1">//静态成员函数的定义</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">test</span> <span class="n">obj1</span><span class="p">;</span>
      <span class="n">test</span> <span class="n">obj2</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 0</span>

      <span class="n">obj1</span><span class="p">.</span><span class="n">fun</span><span class="p">();</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">obj2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="c1">//Output: 1 1</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>静态成员函数</strong><br />
特点：
    <ol>
      <li>只能访问类内声明的其他静态成员（函数或变量）</li>
      <li>调用时使用类名，而非对象名<br />
```cpp
  class test{
  public:
   static int showA() { return a; }
   void fun() { a++; }
  private:
   static int a;
  };</li>
    </ol>

    <p>int test::a;  //静态成员函数的定义</p>

    <p>int main(){
      test obj1;
      cout « test::showA() « endl;
      //Output: 0</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  obj1.fun();
  cout &lt;&lt; test::showA() &lt;&lt; endl;
  //Output: 1   } ``` &lt;br&gt;
</code></pre></div>    </div>
  </li>
  <li><strong>常量成员函数</strong><br />
可将不改变任何类内数据的函数声明为常量成员函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">get_balance</span><span class="p">()</span>  <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>成员指针</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">A</span><span class="o">::*</span> <span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">m</span><span class="p">;</span>   <span class="c1">//A::* 为“指向类A的成员的指针”， &amp;A::m 为 “类A的成员的地址”  </span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>类与结构体</strong><br />
如果类的所有数据成员都是公有成员，不包含任何成员函数，那么一般使用结构体<br />
<br />
    <h4 id="构造函数"><strong>构造函数</strong></h4>
  </li>
  <li><strong>构造函数(Constructor)</strong><br />
通过构造函数来保证类中数据成员的初始化，可有多个进行重载<br />
当声明对象时，构造函数将自动执行
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//省略成员函数</span>
    <span class="n">clockType</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>  <span class="c1">//带参数的构造函数</span>
    <span class="n">clockType</span><span class="p">();</span>  <span class="c1">//默认构造函数</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">hr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//相关实现</span>
<span class="n">clockType</span><span class="o">::</span><span class="n">clockType</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">){</span>
    <span class="n">hr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">hours</span> <span class="o">&amp;&amp;</span> <span class="n">hours</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">?</span><span class="n">hours</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">minutes</span> <span class="o">&amp;&amp;</span> <span class="n">minutes</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">minutes</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">seconds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">seconds</span> <span class="o">&amp;&amp;</span> <span class="n">seconds</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">seconds</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">clockType</span><span class="o">::</span><span class="n">clockType</span><span class="p">(){</span>
    <span class="n">hr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//也可写为 clockType::clockType(): hr(0), min(0), sec(0) {}</span>
</code></pre></div>    </div>
    <p>构造函数可带默认参数，也称为默认构造函数</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">clockType</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//省略成员函数</span>
    <span class="n">clockType</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">//默认构造函数</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">hr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sec</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//相关实现</span>
<span class="n">clockType</span><span class="o">::</span><span class="n">clockType</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">){</span>
    <span class="n">hr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">hours</span> <span class="o">&amp;&amp;</span> <span class="n">hours</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">?</span><span class="n">hours</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">minutes</span> <span class="o">&amp;&amp;</span> <span class="n">minutes</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">minutes</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">seconds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">seconds</span> <span class="o">&amp;&amp;</span> <span class="n">seconds</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">?</span><span class="n">seconds</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
  <span class="n">clockType</span> <span class="n">myclock1</span><span class="p">;</span>
  <span class="n">clockType</span> <span class="n">myclock2</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>拷贝构造函数(Copy Constructor)</strong><br />
用已经存在的类对象进行初始化需使用拷贝构造函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">myVector</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">myVector</span><span class="p">();</span>
    <span class="n">myVector</span><span class="p">(</span><span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="n">anotherVector</span><span class="p">);</span>    <span class="c1">//拷贝构造函数</span>
    <span class="o">~</span><span class="n">myVector</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">unsigned</span> <span class="n">t_size</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(){</span>
    <span class="n">t_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t_size</span><span class="p">]();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(</span><span class="k">const</span> <span class="n">myVector</span> <span class="o">&amp;</span><span class="n">anotherVector</span><span class="p">){</span>
    <span class="n">t_size</span> <span class="o">=</span> <span class="n">anotherVector</span><span class="p">.</span><span class="n">t_size</span><span class="p">;</span>      <span class="c1">//t_size在向量中会改变，故要拷贝</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t_size</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>    <span class="c1">//深拷贝</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">anotherVector</span><span class="p">.</span><span class="n">p</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>    <span class="c1">//注意需要打括号，优先级问题</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">myVector</span><span class="o">::~</span><span class="n">myVector</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">myVector</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//主函数----------------------------------------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">myVector</span> <span class="n">vec</span><span class="p">;</span>
    <span class="n">myVector</span> <span class="n">vec2</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
    <span class="n">vec2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output:</span>
    <span class="c1">//0 1 2 3 4 5 6 7 8 9</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>析构函数(Destructor)</strong><br />
每个类只能有一个析构函数，在程序退出类对象的作用域（即类对象被释放）时，自动执行类的析构函数。<br />
有指针数据成员的类若有创建动态对象，都需要有析构函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//如在类中new了数组后，在实例退出作用域时需要将其删除，可编写析构函数delete掉</span>
<span class="k">class</span> <span class="nc">myVector</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">myVector</span><span class="p">();</span>
  <span class="o">~</span><span class="n">myVector</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(){</span>
  <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">myVector</span><span class="o">::~</span><span class="n">myVector</span><span class="p">(){</span>
  <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"clear done!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//主函数----------------------------------------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
  <span class="kt">int</span> <span class="n">n_case</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n_case</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">myVector</span> <span class="n">vec</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//Output</span>
<span class="c1">//clear done!</span>
<span class="c1">//clear done!</span>
</code></pre></div>    </div>
    <p><br /></p>
    <h4 id="抽象数据类型abstract-data-type-adt"><strong>抽象数据类型(Abstract data type, ADT)</strong></h4>
    <p>只确定逻辑特性而没有实现细节的数据类型，有3个相关属性：</p>
    <ol>
      <li><code class="highlighter-rouge">类型名称(Data Type Name)</code></li>
      <li><code class="highlighter-rouge">域(Domain)</code>： 即属于ADT的一系列值</li>
      <li><code class="highlighter-rouge">一系列操作(Operations) </code></li>
    </ol>

    <p>由此可定义clockType抽象数据类型如下所示，从中可见，类是实现ADT的一种便利的方法</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dataTypeName</span>
  <span class="n">clockType</span>
<span class="n">domain</span>
  <span class="n">each</span> <span class="n">clockType</span> <span class="n">value</span> <span class="n">is</span> <span class="n">a</span> <span class="n">time</span> <span class="n">of</span> <span class="n">day</span> <span class="n">in</span> <span class="n">the</span> <span class="n">form</span> <span class="n">of</span> <span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span><span class="p">,</span> <span class="n">and</span> <span class="n">seconds</span><span class="p">.</span>
<span class="n">operations</span>
  <span class="n">Set</span> <span class="n">the</span> <span class="n">time</span><span class="p">.</span>
  <span class="n">Return</span> <span class="n">the</span> <span class="n">time</span><span class="p">.</span>
  <span class="p">......</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h4 id="继承is-a关系"><strong>继承(“is-a”关系)</strong></h4>
<ul>
  <li><strong>继承</strong><br />
从现有类的基础上创建新类
    <ul>
      <li><code class="highlighter-rouge">派生类(Derived class)</code> : 创建的新类，创建的新类的新类……</li>
      <li><code class="highlighter-rouge">现有类(Base class)</code> : 从现有类的基础上创建新类</li>
      <li><code class="highlighter-rouge">单继承(Single inheritance)</code> : 派生类从一个基类派生</li>
      <li><code class="highlighter-rouge">多继承(Multiple inheritance)</code> : 派生类从多个基类派生</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//例如：cirle类和rectangle类从shape类派生</span>
  <span class="k">class</span> <span class="nc">circle</span><span class="o">:</span> <span class="k">public</span> <span class="n">shape</span><span class="p">{</span>   <span class="c1">//shape类的public成员变成cirle类的public成员</span>
    <span class="c1">//Do Something</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">circle</span><span class="o">:</span> <span class="k">private</span> <span class="n">rectangle</span><span class="p">{</span>    <span class="c1">//shape类的public成员变成cirle类的private成员(private可省略)</span>
    <span class="c1">//Do Something</span>
  <span class="p">};</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>基类成员函数重定义</strong><br />
在baseClass中包含print函数，在derivedClass中也包含print函数且参数列表相同，则为基类成员函数重定义
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">baseClass</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
    <span class="n">baseClass</span><span class="p">()</span> <span class="p">{</span><span class="n">base_var</span> <span class="o">=</span> <span class="s">"base_var"</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">base_var</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">derivedClass</span><span class="o">:</span> <span class="k">public</span> <span class="n">baseClass</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
    <span class="n">derivedClass</span><span class="p">()</span>  <span class="p">{</span><span class="n">derived_var</span> <span class="o">=</span> <span class="s">"derived_var"</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">derived_var</span><span class="p">;</span>
 <span class="p">};</span>

<span class="kt">void</span> <span class="n">baseClass</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base_var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">derivedClass</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="n">baseClass</span><span class="o">::</span><span class="n">print</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">derived_var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">baseClass</span> <span class="n">base_object</span><span class="p">;</span>
    <span class="n">derivedClass</span> <span class="n">derived_object</span><span class="p">;</span>
    <span class="n">base_object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">// Output:</span>
    <span class="c1">// derived_var</span>

    <span class="n">derived_object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output:</span>
    <span class="c1">// base_var</span>
    <span class="c1">// derived_var</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>基类和派生类的构造函数</strong><br />
派生类执行自身构造函数和触发基类构造函数代码如下，值得一提的是，派生类会先调用基类构造函数，再调用自身构造函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">baseClass</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
    <span class="n">baseClass</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">base_var</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">derivedClass</span><span class="o">:</span> <span class="k">public</span> <span class="n">baseClass</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
    <span class="n">derivedClass</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">,</span> <span class="n">string</span> <span class="n">var2</span><span class="p">);</span>  <span class="c1">//var是给derviedClass的，var2是给baseClass的</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">derived_var</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ---------------------------------------</span>
<span class="n">baseClass</span><span class="o">::</span><span class="n">baseClass</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span> <span class="o">=</span> <span class="s">"base_bar by default"</span><span class="p">){</span>    <span class="c1">//基类构造函数</span>
    <span class="n">base_var</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">derivedClass</span><span class="o">::</span><span class="n">derivedClass</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span> <span class="o">=</span> <span class="s">"derived_var"</span><span class="p">,</span>
 <span class="n">string</span> <span class="n">var2</span> <span class="o">=</span> <span class="s">"base_var provoked by derivedClass"</span><span class="p">)</span><span class="o">:</span><span class="n">baseClass</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">//触发基类构造函数</span>
    <span class="n">derived_var</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">baseClass</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base_var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">derivedClass</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="n">baseClass</span><span class="o">::</span><span class="n">print</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">derived_var</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ---------------------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">baseClass</span> <span class="n">base_object</span><span class="p">;</span>
    <span class="n">derivedClass</span> <span class="n">derived_object</span><span class="p">;</span>
    <span class="n">base_object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">// Output:</span>
    <span class="c1">// base_var by default</span>

    <span class="n">derived_object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">// Output:</span>
    <span class="c1">// base_var provoked by derivedClass</span>
    <span class="c1">// derived_var</span>

    <span class="n">derivedClass</span> <span class="n">derived_object2</span><span class="p">(</span><span class="s">"derived_bar by user"</span><span class="p">,</span> <span class="s">"base_bar by user"</span><span class="p">);</span>
    <span class="n">derived_object2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">// Output:</span>
    <span class="c1">// base_bar by user</span>
    <span class="c1">// derived_bar by user</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>类保护成员(protected)</strong>  <br />
可访问性介于public和private之间，派生类可以直接访问基类protected成员 <br />
<br /></li>
  <li><strong>继承：public, private, protected</strong><br />
假设B Class 从 A Class派生，A成员在B成员中的属性如下表  <br />
下表中√表示可以直接访问，〇表示可以间接访问，×表示不能访问（除友元函数） <br />
（友元函数通吃一切！）</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">memberAccessSpecifier A</th>
      <th style="text-align: center">A’s public</th>
      <th style="text-align: center">A’s protected</th>
      <th style="text-align: center">A’s private</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">public</td>
      <td style="text-align: center">√ (public)</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">×</td>
    </tr>
    <tr>
      <td style="text-align: center">protected</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">×</td>
    </tr>
    <tr>
      <td style="text-align: center">private</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">〇 (protected)</td>
      <td style="text-align: center">×</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<h4 id="组成has-a关系"><strong>组成(“has-a”关系)</strong></h4>
<p>如在personType类中包含dataType类和personalType类，代码如下</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//datatype类-------------------------------------------------------</span>
  <span class="k">class</span> <span class="nc">dateType</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">dateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">dYear</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">dMonth</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">dDay</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">dateType</span><span class="o">::</span><span class="n">dateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="mi">2018</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="mi">30</span><span class="p">){</span>   <span class="c1">//dataType的默认构造函数</span>
      <span class="n">dYear</span> <span class="o">=</span> <span class="n">year</span><span class="p">;</span>
      <span class="n">dMonth</span> <span class="o">=</span> <span class="n">month</span><span class="p">;</span>
      <span class="n">dDay</span> <span class="o">=</span> <span class="n">day</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">dateType</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Date: "</span> <span class="o">&lt;&lt;</span> <span class="n">dYear</span> <span class="o">&lt;&lt;</span> <span class="s">"-"</span> <span class="o">&lt;&lt;</span> <span class="n">dMonth</span> <span class="o">&lt;&lt;</span> <span class="s">"-"</span> <span class="o">&lt;&lt;</span> <span class="n">dDay</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// personalType类----------------------------------------------</span>
  <span class="k">class</span> <span class="nc">personalType</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">personalType</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">string</span> <span class="n">dName</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">personalType</span><span class="o">::</span><span class="n">personalType</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"null"</span><span class="p">){</span>
      <span class="n">dName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">personalType</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Name: "</span> <span class="o">&lt;&lt;</span> <span class="n">dName</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//persoanlInfo类--------------------------------------------------</span>
  <span class="k">class</span> <span class="nc">personalInfo</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">personalInfo</span><span class="p">();</span>
      <span class="n">personalInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="n">string</span> <span class="n">name</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">personalType</span> <span class="n">personalName</span><span class="p">;</span>
      <span class="n">dateType</span> <span class="n">bDay</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">personalInfo</span><span class="o">::</span><span class="n">personalInfo</span><span class="p">(){}</span>    <span class="c1">//使用对象成员构造函数的默认值</span>
  <span class="n">personalInfo</span><span class="o">::</span><span class="n">personalInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span>
     <span class="n">string</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span><span class="n">personalName</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">bDay</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">){}</span>  <span class="c1">//向成员对象的构造函数传递参数</span>

  <span class="kt">void</span> <span class="n">personalInfo</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">personalName</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
      <span class="n">bDay</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">//主函数----------------------------------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">personalInfo</span> <span class="n">student</span><span class="p">;</span>
    <span class="n">student</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output</span>
    <span class="c1">//Name: null</span>
    <span class="c1">//Date: 2018-2-30</span>

    <span class="n">personalInfo</span> <span class="n">student2</span><span class="p">(</span><span class="mi">1999</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s">"your nick name"</span><span class="p">);</span>
    <span class="n">student2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output</span>
    <span class="c1">//Name: your nick name</span>
    <span class="c1">//Date: 1999-9-9</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="ood面向对象程序设计-和-oop面向对象编程"><strong>OOD(面向对象程序设计) 和 OOP(面向对象编程)</strong></h4>
<p><strong>OOD的三个基本特征</strong><br />
    1. <code class="highlighter-rouge">封装</code>： 把数据和数据上的操作组合在一个独立单元中的能力 (类 class)<br />
    2. <code class="highlighter-rouge">继承</code>： 在现有的对象基础上创建新的对象的能力 (继承inheritance, 组合)<br />
    3. <code class="highlighter-rouge">多态</code>： 使用相同表达式指定不同操作的能力</p>

<p><br /></p>
<h4 id="纯虚函数"><strong>纯虚函数</strong></h4>
<p>C++支持两种类：<code class="highlighter-rouge">抽象类</code>和<code class="highlighter-rouge">具体类</code>，抽象类中包含没有实现的成员函数（纯虚函数），纯虚函数用0作为初始值<br />
具体类是没有纯虚函数的类，只有具体类才可实例化，抽象类一般作为基类派生出具体类<br />
下面是一个具体类的栗子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">linearList</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">linearList</span><span class="p">()</span> <span class="p">{}</span>    <span class="c1">//析构函数需要为虚函数，作用是能调用引用对象中数据类型的析构函数</span>
      <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span>  <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="kt">int</span> <span class="n">size</span><span class="p">()</span>  <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">erase</span><span class="p">(</span><span class="kt">int</span> <span class="n">theIndex</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="虚函数"><strong>虚函数</strong></h4>
<p>参考1里面似乎写的不好，或者是本人愚笨…故用 <a href="https://baike.baidu.com/item/%E8%99%9A%E5%87%BD%E6%95%B0/2912832?fr=aladdin">百度百科——虚函数</a> 和 <a href="https://www.zhihu.com/question/23971699">知乎——c++虚函数的作用是什么？</a> 加以辅助<br />
在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，可实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数<br />
虚函数的绑定发生在程序执行期间(动态绑定 Run-time Binding)，在编译时，编译器向系统提供必要信息，使得运行时系统能产生实际代码来调用相应函数<br />
另外注意：<strong>如果基类包含了虚函数，基类的析构函数同时也要设为虚函数</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>   <span class="c1">//只需要在基类加上virtual，派生类不需要</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's in A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">B</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's in B"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">callPrint</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">){</span>   <span class="c1">//注意使用引用或者指针传参</span>
      <span class="n">p</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// -----------------------------------</span>
  <span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
      <span class="n">A</span> <span class="n">instanceA</span><span class="p">;</span>
      <span class="n">B</span> <span class="n">instanceB</span><span class="p">;</span>
      <span class="n">callPrint</span><span class="p">(</span><span class="n">instanceA</span><span class="p">);</span>
      <span class="n">callPrint</span><span class="p">(</span><span class="n">instanceB</span><span class="p">);</span>
      <span class="c1">//Output：</span>
      <span class="c1">//It's in A</span>
      <span class="c1">//It's in B</span>

      <span class="c1">//若不加virtual，Output：</span>
      <span class="c1">//It's in A</span>
      <span class="c1">//It's in A</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h4 id="类型转换"><strong>类型转换</strong></h4>
<ul>
  <li><strong>基本类型 -&gt; 类</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">myString</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">myString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span>
    <span class="n">myString</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">myString</span><span class="o">::</span><span class="n">myString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">myString</span> <span class="n">s1</span><span class="p">;</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">myString</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="s">"Apple"</span><span class="p">));</span>  <span class="c1">//从char*类型到myString类型，通过隐式调用构造函数</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>类 -&gt; 基本类型</strong><br />
重载类型转换符函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//以立方转原来的数为栗子</span>
<span class="k">class</span> <span class="nc">cube</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">cube</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">res</span><span class="p">(</span><span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">operator</span> <span class="kt">double</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pow</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="p">;</span> <span class="p">}</span>    <span class="c1">//重载类型转换符</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">res</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">cube</span> <span class="n">num</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="mf">4.0</span><span class="p">));</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="kt">double</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: 4</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>类A -&gt; 类B</strong><br />
类A转换操作符，类B使用构造函数
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//以立方转开方为栗子</span>
<span class="k">class</span> <span class="nc">square</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">square</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">res</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num</span><span class="p">))</span> <span class="p">{}</span>
    <span class="n">square</span><span class="p">(</span><span class="k">const</span> <span class="n">square</span><span class="o">&amp;</span> <span class="n">obj2</span><span class="p">);</span>   <span class="c1">//复制拷贝函数</span>
    <span class="kt">double</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">res</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">cube</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">cube</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">res</span><span class="p">(</span><span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="o">*</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">operator</span> <span class="n">square</span><span class="p">();</span>    <span class="c1">//重载操作符</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">res</span><span class="p">;</span>
<span class="p">};</span>


<span class="n">cube</span><span class="o">::</span><span class="k">operator</span> <span class="n">square</span><span class="p">(){</span>
    <span class="kt">double</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">square</span><span class="o">::</span><span class="n">square</span><span class="p">(</span><span class="k">const</span> <span class="n">square</span> <span class="o">&amp;</span><span class="n">obj2</span><span class="p">){</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">obj2</span><span class="p">.</span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ---------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">cube</span> <span class="n">num</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="mf">4.0</span><span class="p">));</span>
    <span class="n">square</span> <span class="n">num2</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: 2</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
    <h4 id="重载"><strong>重载</strong></h4>
  </li>
  <li><strong>this指针</strong><br />
this指针为指向对象自己的指针
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>   <span class="k">const</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">get</span><span class="p">()</span>   <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">print</span><span class="p">()</span>  <span class="k">const</span>  <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>

<span class="n">A</span> <span class="n">A</span><span class="o">::</span><span class="n">get</span><span class="p">()</span> <span class="k">const</span>  <span class="p">{</span> <span class="k">return</span>  <span class="o">*</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">A</span> <span class="n">instanceA</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">instanceB</span><span class="p">;</span>
    <span class="n">instanceA</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">instanceA</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">instanceB</span> <span class="o">=</span> <span class="n">instanceA</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="n">instanceB</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//一个神奇的栗子</span>
<span class="k">class</span> <span class="nc">person</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">person</span><span class="o">&amp;</span> <span class="n">setFirstName</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">);</span>   <span class="c1">//此处返回的是引用</span>
    <span class="n">person</span><span class="o">&amp;</span> <span class="n">setLastName</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">first_name</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">last_name</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">person</span><span class="o">&amp;</span> <span class="n">person</span><span class="o">::</span><span class="n">setFirstName</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">){</span> <span class="n">first_name</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
<span class="n">person</span><span class="o">&amp;</span> <span class="n">person</span><span class="o">::</span><span class="n">setLastName</span><span class="p">(</span><span class="n">string</span> <span class="n">var</span><span class="p">){</span> <span class="n">last_name</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">person</span><span class="o">::</span><span class="n">print</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">first_name</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">last_name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">person</span> <span class="n">null</span><span class="p">;</span>
    <span class="n">null</span><span class="p">.</span><span class="n">setFirstName</span><span class="p">(</span><span class="s">"Name"</span><span class="p">).</span><span class="n">setLastName</span><span class="p">(</span><span class="s">"Error"</span><span class="p">);</span>  <span class="c1">//因为返回引用且为自身*this，故可连续用两次.</span>
    <span class="n">null</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output</span>
    <span class="c1">//Name Error</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>类的友元函数(Friend Function)</strong><br />
友元函数指在类作用域范围之外的函数，它是类的非成员函数，但是能访问类的私有数据成员
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">B</span><span class="p">;</span>    <span class="c1">//前置声明，因为下面的函数cSwap需要用到</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">//下面一句是友元函数，函数原型前需加上friend</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">cSwap</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">cA</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">cB</span><span class="p">);</span>  <span class="c1">//这是一个交换两个类数据的函数，需要用到友元函数，注意传的是引用</span>
    <span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">B</span><span class="p">()</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">cSwap</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">cA</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">cB</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">get</span><span class="p">(){</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">cSwap</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">cA</span><span class="p">,</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">cB</span><span class="p">){</span>    <span class="c1">//友元函数定义，前面不需要加上friend</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cA</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">cA</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cB</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">cB</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ---------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">A</span> <span class="n">instanceA</span><span class="p">;</span>
    <span class="n">B</span> <span class="n">instanceB</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">instanceA</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">instanceB</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: 1 2</span>

    <span class="n">cSwap</span><span class="p">(</span><span class="n">instanceA</span><span class="p">,</span> <span class="n">instanceB</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">instanceA</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">instanceB</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: 2 1</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>重载运算符限制</strong>
    <ol>
      <li>不能改变运算符的优先级和结合律</li>
      <li>不能使用默认参数，不能改变运算符所需参数个数</li>
      <li>不能创建新运算符</li>
      <li>不能重载以下运算符 <br />
    <code class="highlighter-rouge">.</code>  |  <code class="highlighter-rouge">.*</code>  |  <code class="highlighter-rouge">::</code> | <code class="highlighter-rouge">?:</code> | <code class="highlighter-rouge">sizeof</code></li>
      <li>重载运算符 <code class="highlighter-rouge">()</code>, <code class="highlighter-rouge">[]</code>, <code class="highlighter-rouge">-&gt;</code>, <code class="highlighter-rouge">=</code> 的函数一定要声明为类的成员</li>
      <li>重载<code class="highlighter-rouge">&lt;&lt;</code>, <code class="highlighter-rouge">&gt;&gt;</code>一定要作为非成员（友元函数）</li>
      <li>假定OpOverClass类重载运算符op，则：
        <ul>
          <li>若op最左边的操作数不是OpOverClass类型，则重载运算符op的函数一定要作为非成员（友元）</li>
          <li>若重载运算符op的函数是OpOverClass类的成员，则当opo用于OpOverClass类型的对象时，op最左边的操作数必须是OpOverClass类型</li>
        </ul>
      </li>
    </ol>

    <p>（感觉这两点是废话！）<br />
<br /></p>
  </li>
  <li><strong>重载双目运算符</strong>
    <ul>
      <li><strong>作为成员函数重载 +</strong>  （重载- / * 等同理）<br />
以复数相加为栗子
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ComplexNum</span><span class="p">()</span>  <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>
    <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span><span class="p">)</span>   <span class="k">const</span><span class="p">;</span>  <span class="c1">//函数原型</span>
    <span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//重载运算符语法如下面这一句</span>
<span class="n">ComplexNum</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">other_complex_num</span><span class="p">)</span>  <span class="k">const</span><span class="p">{</span>
    <span class="n">ComplexNum</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">res</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span> <span class="o">+</span> <span class="n">other_complex_num</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
    <span class="n">res</span><span class="p">.</span><span class="n">vir</span> <span class="o">=</span> <span class="n">vir</span> <span class="o">+</span> <span class="n">other_complex_num</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="n">display</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">vir</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// -------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">ComplexNum</span> <span class="n">num3</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="p">;</span>
    <span class="n">num3</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="c1">//Output: 3+6i</span>
<span class="p">}</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
      <li><strong>作为成员函数重载关系运算符</strong>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>
    <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span><span class="p">)</span>   <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">other_complex_num</span><span class="p">)</span>  <span class="k">const</span><span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">real</span> <span class="o">==</span> <span class="n">other_complex_num</span><span class="p">.</span><span class="n">real</span> <span class="o">&amp;&amp;</span> <span class="n">vir</span> <span class="o">==</span> <span class="n">other_complex_num</span><span class="p">.</span><span class="n">vir</span><span class="p">)</span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// -------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">num1</span> <span class="o">==</span> <span class="n">num2</span><span class="p">)</span><span class="o">?</span><span class="s">"TURE"</span><span class="o">:</span><span class="s">"FALSE"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: FALSE</span>
<span class="p">}</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
      <li><strong>作为非成员函数重载双目运算符</strong><br />
把上面的复数重载+拿下来改改
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ComplexNum</span><span class="p">()</span>  <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>
    <span class="k">friend</span> <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">)</span>   <span class="p">;</span>  <span class="c1">//函数原型1</span>
    <span class="k">friend</span> <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">)</span>   <span class="p">;</span>  <span class="c1">//函数原型2</span>
    <span class="k">friend</span> <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">)</span>   <span class="p">;</span>  <span class="c1">//函数原型3</span>
    <span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//分别重载complex + complex, complex + int, int + complex三种情况</span>
<span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span> <span class="o">&amp;</span><span class="n">second</span><span class="p">){</span>
    <span class="n">ComplexNum</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">res</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
    <span class="n">res</span><span class="p">.</span><span class="n">vir</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">vir</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">){</span>
    <span class="n">ComplexNum</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">res</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">second</span><span class="p">;</span>
    <span class="n">res</span><span class="p">.</span><span class="n">vir</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">){</span>
    <span class="n">ComplexNum</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">res</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">second</span><span class="p">;</span>
    <span class="n">res</span><span class="p">.</span><span class="n">vir</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="n">display</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">vir</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// ---------------------------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">ComplexNum</span> <span class="n">num3</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">num3</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="c1">//Output: 10+6i</span>
<span class="p">}</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
    </ul>
  </li>
  <li><strong>重载流插入(«)和流析取(»)运算符</strong><br />
仍以复数为栗子（这个栗子太好举了！）
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>
    <span class="c1">//&lt;&lt; &gt;&gt; 重载的函数原型如下</span>
    <span class="c1">//注意ostream和istream是不可以改变的，其为输入输出流</span>
    <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">ostreamObject</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">);</span>
    <span class="k">friend</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">istreamObject</span><span class="p">,</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">);</span>  <span class="c1">//注意没有const，const就不能输入了！</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">ostreamObject</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">){</span>
    <span class="n">ostreamObject</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">vir</span> <span class="o">&lt;&lt;</span> <span class="s">"i)"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ostreamObject</span><span class="p">;</span>   <span class="c1">//注意return，后续可能接着用到</span>
<span class="p">}</span>

<span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">istreamObject</span><span class="p">,</span> <span class="n">ComplexNum</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">){</span>
    <span class="n">istreamObject</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">.</span><span class="n">real</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">.</span><span class="n">vir</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">istreamObject</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// -------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">ComplexNum</span> <span class="n">num3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num3</span><span class="p">;</span>
    <span class="c1">//Input: 3 6</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num1</span> <span class="o">&lt;&lt;</span> <span class="s">" + "</span> <span class="o">&lt;&lt;</span> <span class="n">num2</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">num3</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: (1,2i) + (2,4i) = (3,6i)</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>重载赋值运算符 =</strong><br />
重载 = 运算符，可避免有指针数据成员的类的浅拷贝<br />
这次以之前用过的向量类来举例子
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">myVector</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">myVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">);</span>
    <span class="o">~</span><span class="n">myVector</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">unsigned</span> <span class="n">t_size</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
    <span class="n">t_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t_size</span><span class="p">]();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="n">myVector</span><span class="o">::~</span><span class="n">myVector</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">myVector</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="n">myVector</span><span class="o">::</span><span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">myVector</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">){</span>     <span class="c1">//避免自身复制，浪费时间空间</span>
        <span class="n">t_size</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">t_size</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">p</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//主函数----------------------------------------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">myVector</span> <span class="n">vec</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">myVector</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="n">vec2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output:</span>
    <span class="c1">//0 1 2 3 4</span>
    <span class="c1">//10 11 12 13 14</span>

    <span class="n">vec</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">;</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="n">vec2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Output:</span>
    <span class="c1">//10 11 12 13 14</span>
    <span class="c1">//10 11 12 13 14</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><strong>重载单目运算符</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//重载下标[]，以向量为栗</span>
<span class="k">class</span> <span class="nc">myVector</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">myVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">);</span>
    <span class="o">~</span><span class="n">myVector</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>    <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">);</span>     <span class="c1">//重载下标[]</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">unsigned</span> <span class="n">t_size</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">myVector</span><span class="o">::</span><span class="n">myVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
    <span class="n">t_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t_size</span><span class="p">]();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="n">myVector</span><span class="o">::~</span><span class="n">myVector</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">myVector</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">myVector</span><span class="o">::</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">//主函数----------------------------------------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">myVector</span> <span class="n">vec</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">myVector</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//重载自增运算符</span>
<span class="k">class</span> <span class="nc">ComplexNum</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ComplexNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>   <span class="p">{</span><span class="n">real</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">vir</span> <span class="o">=</span> <span class="n">b</span><span class="p">;}</span>
    <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">++</span><span class="p">();</span>   <span class="c1">//重载前置自增，自减同理</span>
    <span class="n">ComplexNum</span> <span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>  <span class="c1">//重载后置自增，自减同理，其中int i无实际意义，仅起标识为后置的作用</span>
    <span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">vir</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ComplexNum</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="k">operator</span> <span class="o">++</span><span class="p">(){</span>
    <span class="n">ComplexNum</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
    <span class="n">real</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ComplexNum</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="n">ComplexNum</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span> <span class="k">this</span><span class="p">;</span>
    <span class="n">real</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ComplexNum</span><span class="o">::</span><span class="n">display</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">vir</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// -------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">ComplexNum</span> <span class="n">num1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">ComplexNum</span> <span class="n">num2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">num1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="n">num2</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="c1">//Output:</span>
    <span class="c1">//1+2i</span>
    <span class="c1">//2+4i</span>

    <span class="n">num1</span><span class="o">++</span><span class="p">;</span>
    <span class="o">++</span><span class="n">num2</span><span class="p">;</span>
    <span class="n">num1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="n">num2</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="c1">//Output:</span>
    <span class="c1">//2+2i</span>
    <span class="c1">//3+4i</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<h4 id="模板"><strong>模板</strong></h4>
<ul>
  <li><strong>函数模板</strong><br />
C++提供函数模板简化重载函数的过程<br />
以之前写过的larger函数重载为栗
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>  <span class="c1">//模板语法，T是类型，由传参决定</span>
<span class="n">T</span> <span class="n">larger</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// -------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">larger</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: 7</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">larger</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: Z</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">larger</span><span class="p">(</span><span class="mf">9.9999</span><span class="p">,</span> <span class="mf">9.9898</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Output: 9.9999</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>类模板</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>    <span class="c1">//语法需要</span>
<span class="k">class</span> <span class="nc">point</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">point</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">setPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">iy</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">display</span><span class="p">()</span>  <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">point</span><span class="p">(){</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;}</span>   <span class="c1">//注意是point&lt;T&gt;，并且每一处有使用T的地方，前面都要加 template &lt;class T&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">setPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">ix</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">iy</span><span class="p">){</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ix</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">iy</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">display</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x is "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", y is "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>

<span class="c1">// -------------------------</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">point</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>
    <span class="n">point</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">;</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">setPoint</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="n">p2</span><span class="p">.</span><span class="n">setPoint</span><span class="p">(</span><span class="mf">3.1415</span><span class="p">,</span> <span class="mf">2.71</span><span class="p">);</span>

    <span class="n">p1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="c1">//Output: x is 5, y is 6</span>

    <span class="n">p2</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="c1">//Output: x is 3.1415, y is 2.71</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

    </article>
    
</div>

<section class="author-detail">
    <section class="post-footer-item author-card">
        <div class="avatar">
            <img src="http://localhost:4000/assets/img/profile.png" alt="">
        </div>
        <div class="author-name" rel="author">HouZAJ</div>
        <div class="bio">
            <p>A developing developer & terrible designer!</p>
        </div>
        
    </section>
    <section class="post-footer-item read-next">
        
        <div class="read-next-item">
            <a href="/2018/01/12/DS_Algorithm_summary.html" class="read-next-link"></a>
            <section>
                <span>学习笔记 - 数据结构和算法</span>
                <p>  好好学习哈哈哈哈哈哈哈</p>
            </section>
            
            <div class="filter"></div>
            <img src="" alt="">
            
        </div>
        
        
        <div class="read-next-item">
            <a href="/2017/11/21/maze.html" class="read-next-link"></a>
            <section>
                <span>迷宫问题（MAZE）</span>
                <p>  这是一道OJ题引发的博文和现实的技巧……(不是来看题的同学就翻到最后吧)</p>
            </section>
            
            <div class="filter"></div>
            <img src="http://houzajblog-1252277898.coscd.myqcloud.com/20171125%20MAZE/%E6%9C%AA%E6%A0%87%E9%A2%98-2-01.png?sign=Tw2F9KLYM+BaU+RCP4PA3KAnGz5hPTEyNTIyNzc4OTgmaz1BS0lEVXVYME83aHpET1RSQ3Z2cWNJaHk5QzY3QjdLVGNSanEmZT0xNTE0MjE0ODY5JnQ9MTUxMTYyMjg2OSZyPTcwMDI1NzAwNSZmPS8yMDE3MTEyNSUyME1BWkUvJUU2JTlDJUFBJUU2JUEwJTg3JUU5JUEyJTk4LTItMDEucG5nJmI9aG91emFqYmxvZw==" alt="">
            
        </div>
        
    </section>
    
</section>

<footer class="g-footer">
    <section>HouZAJ Blog © 2018</section>
    <section>Powered by <a href="//jekyllrb.com">Jekyll</a> | <a href="https://github.com/kaeyleo/jekyll-theme-H2O">Modified from Theme H2O, the author is liaokeyu</a></section>
</footer>


<script src="/assets/js/social-share.min.js"></script>
<script>
    socialShare('.social-share', {
        sites: ['wechat','weibo','github'],
        wechatQrcodeTitle: "分享到微信朋友圈",
        wechatQrcodeHelper: '<p>扫码后点击右上角</p><p>将本文分享至朋友圈</p>'
    });
</script>
<script data-cfasync=false>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
/*写入自己的disqus信息*/
s.src = 'https://liaokeyu.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<script data-cfasync=false src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
<script data-cfasync=false src="https://cdn.bootcss.com/clipboard.js/1.7.1/clipboard.js"></script>
<script data-cfasync=false src="/assets/js/prism.js"></script>
<script data-cfasync=false src="/assets/js/index.min.js"></script>
</body>
</html>
