---
layout: post
title: 'JAVA学习笔记'
date: 2018-6-13
author: HouZAJ
cover: 'http://houzajblog-1252277898.coscd.myqcloud.com/20180613%20Problem0613/20180613-01.png'
tags: Problem
---

> JAVA学习笔记     

<br>

<iframe type="text/html" src="http://music.163.com/outchain/player?type=2&id=407002778&auto=0&height=66" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86"></iframe>      

<br>

### 前言   
开始啃JAVA，参考资料如下  
1. JAVA程序设计 —— 学堂在线
2. Thinking in JAVA  
<br>

### 基础语法 —— 题
这部分个人想了很久，最后决定以过题的方式写笔记，毕竟语法这种东西怎么说都是虚的...  
<br>

#### 一维数组与排序  
> **字符串排序**  
用Java编写一个能对一组字符串按字典序升序排序的程序 输入为N和N行字符串，需要按行输出字符串升序排序的结果  
如输入  
3  
Abc  
Abe  
Abd  
输出：  
Abc  
Abd  
Abe  

```java
  import java.util.*;

  public class Main{
      public static void main(String[] args){
          //创建Scanner类对象，用于输入
          Scanner cin = new Scanner(System.in);
          int n = cin.nextInt();
          String[] a = new String[n];
          for(int i = 0; i < n; i++){
              a[i] = cin.next();
          }
          //数组排序
          Arrays.sort(a);
          for(int i = 0; i < n; i++){
              System.out.println(a[i]);
          }
      }
  }
```
<br>

#### 一维数组和方法
> **偶数分解**  
歌德巴赫猜想：任何一个大于六的偶数可以拆分成两个质数的和，打印出所有的可能  
输入n为偶数,输出n的所有分界可能  
如输入  
100  
输出：  
100=3+97  
100=11+89  
100=17+83  
100=29+71  
100=41+59  
100=47+53  

```java
  import java.util.*;

  public class Main {
      static int[] prime;
      static int[] used;
      static int ppos;

      public static void main(String[] args) {
          Euler();

          Scanner cin = new Scanner(System.in);
          int n = cin.nextInt();
          for(int i = 0; i < ppos && prime[i] <= n/2; i++){
              if(used[n - prime[i]] == 1){
                  System.out.printf("%d=%d+%d", n, prime[i], n - prime[i]);
                  System.out.println();
              }
          }
      }

      //main中直接调用的方法，声明为静态static
      //实际上是因为static方法只能访问static方法
      public static void Euler(){
          int n = (int)1e6;
          prime = new int[n];
          used = new int[n];
          //填充数组为1
          Arrays.fill(used, 1);
          ppos = 0;

          for(int i = 2; i < n; i++){
              if(used[i] == 1){
                  prime[ppos++] = i;
              }
              for(int j = 0; i*prime[j] < n; j++){
                  used[i*prime[j]] = 0;
                  if(i%prime[j] == 0)     break;
              }
          }
      }
  }
```
<br>

#### 方法和递归
> **最大公约数和最小公倍数**  
输入两个正整数m和n，求其最大公约数和最小公倍数  
输入  
34 8  
输出  
2 136  

```java
  import java.util.*;

  public class Main {
      public static void main(String[] args) {
          Scanner cin = new Scanner(System.in);
          int a = cin.nextInt();
          int b = cin.nextInt();
          System.out.println(gcd(a, b) + " " + lcm(a, b));
      }

      //递归
      public static int gcd(int a, int b){
          return (b == 0 ? a : gcd(b, a%b));
      }
      public static int lcm(int a, int b){
          return a*b/gcd(a, b);
      }
  }
```

#### 二维数组  
> **扫雷**  
给定nxm的矩阵，其中'\*'代表雷，'.'则不是雷，求对应将'.'换成周围有几颗雷的矩阵  
如输入  
4 4  
\*...  
....  
.\*..  
....  
则输出  
\*100  
2210  
1\*10  
1110  

```java
  import java.util.Scanner;

  public class Main {
      public static void main(String[] args){
          Scanner cin = new Scanner(System.in);
          int csn = 1;
          while(cin.hasNext()){     //相当于检测EOF
              int n = cin.nextInt();
              int m = cin.nextInt();
              if(n == 0 && m == 0)    break;

              String[] str = new String[n];
              char[][] G = new char[n][m];
              for(int i = 0; i < n; i++){
                  str[i] = cin.next();
              }
              //String不能直接修改，需转为char[]

              for(int i = 0; i < n; i++){
                  for(int j = 0; j < m; j++){
                      G[i][j] = str[i].charAt(j);   //String转char
                      if(G[i][j] == '.'){
                          G[i][j] = '0';
                      }
                  }
              }

              for(int i = 0; i < n; i++){
                  for(int j = 0; j < m; j++) {
                      if (G[i][j] != '*') continue;
                      for (int dx = -1; dx <= 1; dx++) {
                          for (int dy = -1; dy <= 1; dy++) {
                              if(dx == 0 && dy == 0)  continue;
                              int newi = i + dx;
                              int newj = j + dy;
                              if(newi < 0 || newi >= n || newj < 0 || newj >= m || G[newi][newj] == '*')  continue;
                              G[newi][newj]++;
                          }
                      }
                  }
              }

              if(csn > 1)     System.out.println();
              System.out.printf("Field #%d:", csn++);
              System.out.println();
              for(char[] G_row : G){
                  for(char ch : G_row){
                      System.out.print(ch);
                  }
                  System.out.println();
              }
          }
      }
  }
```
<br>

#### Collection  
> **交集**  
> 给定两个数组(数组中不包含相同元素），求两个数组的交集中元素的个数（即共同出现的数，如没有则输出为None） 如输入：  
5  
1 2 4 6 8  
6  
1 2 5 6 7 8  
输出： 4  

```java
  import java.util.*;

  public class Main{
      public static void main(String[] args){
          Scanner cin = new Scanner(System.in);
          int n = cin.nextInt();
          //传入Long，即long的封装类
          HashSet<Long> hset = new HashSet<>();
          for(int i = 0; i < n; i++){
              long tmp;
              tmp = cin.nextInt();
              hset.add(tmp);
          }

          int m = cin.nextInt();
          int ans = 0;
          for(int i = 0; i < m; i++){
              long tmp;
              tmp = cin.nextInt();
              if(hset.contains(tmp) == true){
                  ans++;
              }
          }
          System.out.println(ans != 0 ? ans : "None");
      }
  }
```

### 基础语法 —— 细究
