---
layout: post
title: '刷题记（RMQ） —— 2018.6.4'
date: 2018-6-4
author: HouZAJ
cover: 'http://houzajblog-1252277898.coscd.myqcloud.com/20180603%20Problem0603/20180604-01.png'
tags: Problem
---

> RMQ   

<br>

<iframe type="text/html" src="http://music.163.com/outchain/player?type=2&id=29774728&auto=0&height=66" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86"></iframe>      

<br>

### 前言   
RMQ是区间最值查询，多种算法可解，本文采用ST算法、线段树和莫队算法求解    
<br>

###  Balanced Lineup - POJ 3264
![](http://houzajblog-1252277898.coscd.myqcloud.com/20180603%20Problem0603/Balanced%20Lineup%20-%20POJ%203264.jpg)
**题意**  
询问给定区间中最大值和最小值的差值  
**思路**  
ST算法：  
```cpp
	#include <iostream>
	#include <cstdio>
	#include <algorithm>
	#include <cstring>
	#include <cmath>
	#include <stack>
	#include <queue>
	#include <map>
	using namespace std;
	typedef long long ll;
	const int N = 50005;
	const int M = 20;

	int arr_max[N][M];
	int arr_min[N][M];

	void RMQ(int n){
	    for(int j = 1; (1 << j) <= n; j++){
	        for(int i = 1; i + (1 << j) - 1 <= n; i++){
	            arr_max[i][j] = max(arr_max[i][j - 1], arr_max[i + (1 << (j - 1))][j - 1]);
	            arr_min[i][j] = min(arr_min[i][j - 1], arr_min[i + (1 << (j - 1))][j - 1]);
	        }
	    }
	}

	int query(int l, int r, int p){
	    int k = log(r - l + 1)/log(2);
	    if(p == 0)  return max(arr_max[l][k], arr_max[r - (1 << k) + 1][k]);
	    else        return min(arr_min[l][k], arr_min[r - (1 << k) + 1][k]);
	}

	int main(){
	    int n, m;
	    while(~scanf("%d%d", &n, &m)){
	        for(int i = 1; i <= n; i++){
	            scanf("%d", &arr_max[i][0]);
	            arr_min[i][0] = arr_max[i][0];
	        }
	        RMQ(n);

	        while(m--){
	            int p, q;
	            scanf("%d%d", &p, &q);
	            printf("%d\n", query(p, q, 0) - query(p, q, 1));
	        }
	    }
	}
```
<br>
线段树：  
```cpp
	#include <cstdio>
	#include <iostream>
	#include <cstring>
	#include <cstdlib>
	#include <ctime>
	#define lson l, m, rt << 1
	#define rson m + 1, r, rt << 1 | 1
	using namespace std;
	const int N = 200000 + 15;
	const int inf = 0x3f3f3f3f;

	int sum[N << 2][2];
	int a[N];

	void pushUp(int rt){
	    sum[rt][0] = max(sum[rt << 1][0], sum[rt << 1 | 1][0]);
	    sum[rt][1] = min(sum[rt << 1][1], sum[rt << 1 | 1][1]);
	}

	void build(int l, int r, int rt){
	    if(l == r){
	        sum[rt][0] = sum[rt][1] = a[l];
	        return;
	    }
	    int m = (l + r) >> 1;
	    build(lson);
	    build(rson);
	    pushUp(rt);
	}

	int query(int ql, int qr, int p, int l, int r, int rt){
	    if(ql <= l && r <= qr){
	        return sum[rt][p];
	    }
	    int ans = (p == 0 ? 0 : inf);
	    int m = (l + r) >> 1;
	    if(ql <= m)     ans = query(ql, qr, p, lson);
	    if(m <  qr){
	        if(p == 0)  ans = max(ans, query(ql, qr, p, rson));
	        else        ans = min(ans, query(ql, qr, p, rson));
	    }
	    return ans;
	}

	int main(){
	    int n, q;
	    while(~scanf("%d%d", &n, &q)){
	        for(int i = 1; i <= n; i++){ scanf("%d", &a[i]); }
	        build(1, n, 1);

	        while(q--){
	            int l, r;
	            scanf("%d%d", &l, &r);
	            printf("%d\n", query(l, r, 0, 1, n, 1) - query(l, r, 1, 1, n, 1));
	        }
	    }
	}
```
<br>
莫队算法：（如果离散化应该能更快）  
```cpp
	#include <iostream>
	#include <cstdio>
	#include <algorithm>
	#include <cstring>
	#include <cmath>
	using namespace std;
	typedef long long ll;
	const int N = 200005;
	const int M = 1e6 + 15;
	const int inf = 0x3f3f3f3f;

	int  unit;
	struct node{
	    int l, r, id;
	    bool operator <(const node& b)  const{
	        if(l/unit != b.l/unit)  return l/unit < b.l/unit;
	        else                    return r < b.r;
	    }
	};

	node que[N];
	int  a[N];
	int  ans[N];
	int  cnt[M];
	int  ans_max = 0, ans_min = inf;


	void add(int p){
	    ans_max = max(ans_max, a[p]);
	    ans_min = min(ans_min, a[p]);
	    cnt[a[p]]++;
	}

	void remove(int p){
	    cnt[a[p]]--;
	    for(int j = ans_max; ; j--){
	        if(cnt[j]){
	            ans_max = j;
	            break;
	        }
	    }
	    for(int j = ans_min; ; j++){
	        if(cnt[j]){
	            ans_min = j;
	            break;
	        }
	    }
	}

	int main(){
	    int n, q;
	        while(~scanf("%d%d", &n, &q)){
	            memset(cnt, 0, sizeof(cnt));
	            for(int i = 1; i <= n; i++){ scanf("%d", &a[i]); }
	            for(int i = 1; i <= q; i++){
	                scanf("%d%d", &que[i].l, &que[i].r);
	                que[i].id = i;
	            }
	            unit = sqrt(n);
	            sort(que + 1, que + 1 + q);

	            int l = 1, r = 0;
	            for(int i = 1; i <= q; i++){
	                while(l < que[i].l)   remove(l++);
	                while(que[i].l < l)   add(--l);
	                while(r < que[i].r)   add(++r);
	                while(que[i].r < r)   remove(r--);
	                ans[que[i].id] = ans_max - ans_min;
	            }

	            for(int i = 1; i <= q; i++){ printf("%d\n", ans[i]); }
	        }
	}
```
